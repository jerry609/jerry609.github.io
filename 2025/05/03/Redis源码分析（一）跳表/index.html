<!DOCTYPE html>
<html lang="">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="x5-fullscreen" content="true">
<meta name="full-screen" content="yes">
<meta name="theme-color" content="#317EFB" />
<meta content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=0" name="viewport">
<meta name="description" content="[toc] Redis跳表实现详解跳表只在Redis的有序集合中用到了。  什么场景下会需要用到跳表和红黑树 普通链表的查找复杂度，为什么双向链表可以降低查询复杂度  1. 核心数据结构 1.1 跳表节点123456789typedef struct zskiplistNode &#123;    sds ele;                  &#x2F;&#x2F; 成员对象(键)    double sco">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis源码分析（一）跳表">
<meta property="og:url" content="https://jerry609.github.io/2025/05/03/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E8%B7%B3%E8%A1%A8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[toc] Redis跳表实现详解跳表只在Redis的有序集合中用到了。  什么场景下会需要用到跳表和红黑树 普通链表的查找复杂度，为什么双向链表可以降低查询复杂度  1. 核心数据结构 1.1 跳表节点123456789typedef struct zskiplistNode &#123;    sds ele;                  &#x2F;&#x2F; 成员对象(键)    double sco">
<meta property="og:locale">
<meta property="og:image" content="https://jerry609.github.io/img/404.jpg">
<meta property="og:image" content="https://jerry609.github.io/img/404.jpg">
<meta property="og:image" content="https://jerry609.github.io/img/404.jpg">
<meta property="og:image" content="https://jerry609.github.io/img/404.jpg">
<meta property="og:image" content="https://jerry609.github.io/img/404.jpg">
<meta property="og:image" content="https://jerry609.github.io/img/404.jpg">
<meta property="article:published_time" content="2025-05-03T05:23:21.000Z">
<meta property="article:modified_time" content="2025-05-03T05:28:30.414Z">
<meta property="article:author" content="Jerry">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jerry609.github.io/img/404.jpg">


<title >Redis源码分析（一）跳表</title>

<!-- Favicon -->

    <link href='/img/favicon.svg?v=2.2.4' rel='icon' type='image/png' sizes='16x16' ></link>


    <link href='/img/favicon.svg?v=2.2.4' rel='icon' type='image/png' sizes='32x32' ></link>



    <link href='/site.webmanifest' rel='manifest' ></link>


<!-- Plugin -->




    
<link rel="stylesheet" href="/css/plugins/bootstrap.row.css">

    
<link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.css">

    
    




<!-- Icon -->

    
<link rel="stylesheet" href="/css/plugins/font-awesome.min.css">




<!-- Variable -->
<script>window.ASYNC_CONFIG = {"hostname":"jerry609.github.io","author":"Jerry","root":"/","typed_text":["有趣的人"],"theme_version":"2.2.4","theme":{"switch":true,"default":"style-light"},"favicon":{"logo":"/img/favicon.svg","icon16":"/img/favicon.svg","icon32":"/img/favicon.svg","apple_touch_icon":null,"webmanifest":"/site.webmanifest","visibilitychange":true,"hidden":"/failure.ico","show_text":"(/≧▽≦/)咦！又好了！","hide_text":"(●—●)喔哟，崩溃啦！"},"i18n":{"placeholder":"搜索文章...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）","author":"本文作者：","copyright_link":"本文链接：","copyright_license_title":"版权声明：","copyright_license_content":"本博客所有文章除特别声明外，均默认采用 undefined 许可协议。","copy_success":"复制成功","copy_failure":"复制失败","open_read_mode":"进入阅读模式","exit_read_mode":"退出阅读模式","notice_outdate_message":"距离上次更新已经 undefined 天了, 文章内容可能已经过时。","sticky":"置顶","just":"刚刚","min":"分钟前","hour":"小时前","day":"天前","month":"个月前"},"swup":false,"plugin":{"flickr_justified_gallery":"https://unpkg.com/flickr-justified-gallery@latest/dist/fjGallery.min.js"},"icons":{"sun":"far fa-sun","moon":"far fa-moon","play":"fas fa-play","email":"far fa-envelope","next":"fas fa-arrow-right","calendar":"far fa-calendar-alt","clock":"far fa-clock","user":"far fa-user","back_top":"fas fa-arrow-up","close":"fas fa-times","search":"fas fa-search","reward":"fas fa-hand-holding-usd","toc_tag":"fas fa-th-list","read":"fas fa-book-reader","arrows":"fas fa-arrows-alt-h","double_arrows":"fas fa-angle-double-down","copy":"fas fa-copy"},"icontype":"font","highlight":{"plugin":"highlighjs","theme":true,"copy":true,"lang":true,"title":"default","height_limit":false},"toc":{"post_title":false},"live_time":{"start_time":"07/4/2024 10:00:00","prefix":"博客已萌萌哒运行 undefined 天"},"danmu":{"enable":false,"el":".trm-banner"}};</script>
<script id="async-page-config">window.PAGE_CONFIG = {"isPost":true,"isHome":false,"postUpdate":"2025-05-03 13:28:30"};</script>

<!-- Theme mode css -->
<link data-swup-theme rel="stylesheet" href="/css/index.css?v=2.2.4" id="trm-switch-style">
<script>
    let defaultMode = ASYNC_CONFIG.theme.default !=='auto' ?  ASYNC_CONFIG.theme.default : (window.matchMedia("(prefers-color-scheme: light)").matches ? 'style-light' : 'style-dark')
    let catchMode = localStorage.getItem('theme-mode') || defaultMode;
    let type = catchMode === 'style-dark' ? 'add' : 'remove';
    document.documentElement.classList[type]('dark')
</script>

<!-- CDN -->


    
    



<!-- Site Analytics -->

 
<meta name="generator" content="Hexo 7.3.0"></head>

<body>

  <!-- app wrapper -->
  <div class="trm-app-frame">

    <!-- page preloader -->
    <div class="trm-preloader">
    <div class="trm-holder">
        <div class="preloader">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
</div>
    <!-- page preloader end -->

    <!-- change mode preloader -->
    <div class="trm-mode-swich-animation-frame">
    <div class="trm-mode-swich-animation">
        <i class="i-sun"><i class="iconfont far fa-sun"></i></i>
        <div class="trm-horizon"></div>
        <i class="i-moon"><i class="iconfont far fa-moon"></i></i>
    </div>
</div>
    <!-- change mode preloader end -->

      <!-- scroll container -->
      <div id="trm-dynamic-content" class="trm-swup-animation">
        <div id="trm-scroll-container" class="trm-scroll-container" style="opacity: 0">
            <!-- top bar -->
            <header class="trm-top-bar">
	<div class="container">
		<div class="trm-left-side">
			<!-- logo -->
<a href="/" class="trm-logo-frame trm-anima-link">
    
        <img alt="logo" src="/img/favicon.svg">
    
    
        <div class="trm-logo-text">
            Zhang<span>Jerry</span>
        </div>
    
</a>
<!-- logo end -->
		</div>
		<div class="trm-right-side">
			<!-- menu -->
<div class="trm-menu">
    <nav>
        <ul>
            
            <li class="menu-item-has-children ">
                <a  href="/" target="">
                    首页
                </a>
                
                <ul>
                    
                    <li>
                        <a  href="/archives2/" target="">
                            archives2
                        </a>
                    </li>
                    
                </ul>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a data-no-swup href="/archives/" target="">
                    归档
                </a>
                
            </li>
            
            <li class="menu-item-has-children ">
                <a data-no-swup href="/categories/" target="">
                    分类
                </a>
                
            </li>
            
        </ul>
    </nav>
</div>
<!-- menu end -->
			
    <!-- mode switcher place -->
    <div class="trm-mode-switcher-place">
        <div class="trm-mode-switcher">
            <i class="iconfont far fa-sun"></i>
            <input class="tgl tgl-light" id="trm-swich" type="checkbox">
            <label class="trm-swich" for="trm-swich"></label>
            <i class="iconfont far fa-moon"></i>
        </div>
    </div>
    <!-- mode switcher place end -->

			
		</div>
		<div class="trm-menu-btn">
			<span></span>
		</div>
	</div>
</header>
            <!-- top bar end -->

            <!-- body -->
            
<div class="trm-content-start">
    <!-- banner -->
    <div class="trm-banner">
    
    <!-- banner cover -->
    <img style="object-position:top;object-fit:cover;" alt="banner" class="trm-banner-cover" src="/img/banner.png">
    <!-- banner cover end -->
    

    <!-- banner content -->
    <div class="trm-banner-content trm-overlay">
        <div class="container">
            <div class="row">
                
                <div class="col-lg-4"></div>
                
                <div class="col-lg-8">

                    <!-- banner title -->
                    <div class="trm-banner-text ">
                        <div class="trm-label trm-mb-20">
                            NEWS LETTER
                        </div>
                        <h1 class="trm-mb-30 trm-hsmb-font">
                            Redis源码分析（一）跳表
                        </h1>

                        
                            <ul class="trm-breadcrumbs trm-label">
                                <li>
                                    <a href="/" class="trm-anima-link">Home</a>
                                </li>
                                <li>
                                    <span>
                                        2025
                                    </span>
                                </li>
                            </ul>
                        
                    </div>
                    <!-- banner title end -->

                    <!-- scroll hint -->
                    <span id="scroll-triger" class="trm-scroll-hint-frame">
                        <div class="trm-scroll-hint"></div>
                        <span class="trm-label">Scroll down</span>
                    </span>
                    <!-- scroll hint end -->

                </div>
            </div>
        </div>
    </div>
    <!-- banner content end -->
</div>
    <!-- banner end -->
    <div class="container">
        <div class="row">
            
                <div class="trm-page-sidebar col-lg-4 hidden-sm">
                    <!-- main card -->
                    <div class="trm-main-card-frame trm-sidebar">
    <div class="trm-main-card"> 
        <!-- card header -->
<div class="trm-mc-header">
    <div class="trm-avatar-frame trm-mb-20">
        <img alt="Avatar" class="trm-avatar" src="/img/Jerry.png">
    </div>
    <h5 class="trm-name trm-mb-15">
        Jerry
    </h5>
    
        <div class="trm-label">
            成为一个
            <span class="trm-typed-text">
                <!-- Words for theme.user.typedText -->
            </span>
        </div>
    
</div>
<!-- card header end -->
        <!-- sidebar social -->

<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<div class="trm-social">
    
        <a href="https://github.com/jerry609" title="github" rel="nofollow" target="_blank">
            <i class="iconfont fab fa-github"></i>
        </a>
    
</div>

<!-- sidebar social end -->
        <!-- info -->
<div class="trm-divider trm-mb-40 trm-mt-40"></div>
<ul class="trm-table trm-mb-20">
    
        <li>
            <div class="trm-label">
                地址:
            </div>
            <div class="trm-label trm-label-light">
                福建/北京
            </div>
        </li>
    
        <li>
            <div class="trm-label">
                年龄:
            </div>
            <div class="trm-label trm-label-light">
                6岁100多个月
            </div>
        </li>
    
</ul>
<!-- info end -->

        
    <div class="trm-divider trm-mb-40 trm-mt-40"></div>
    <!-- action button -->
    <div class="text-center">
        <a href="mailto:jeffy353866@gmail.com" class="trm-btn">
            联系我
            <i class="iconfont far fa-envelope"></i>
        </a>
    </div>
    <!-- action button end -->

    </div>
</div>
                    <!-- main card end -->
                </div>
            
            <div class="trm-page-content col-lg-8">
                <div id="trm-content" class="trm-content">
                    <div class="trm-post-info row hidden-sm">
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-calendar-alt trm-icon"></i><br>
            05/03
        </div>
    </div>
    <div class="col-sm-4">
        <div class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-clock trm-icon"></i><br>
            13:23
        </div>
    </div>
    <div class="col-sm-4">
        <div id="post-author" class="trm-card trm-label trm-label-light text-center">
            <i class="iconfont far fa-user trm-icon"></i><br>
            Jerry
        </div>
    </div>
</div>
<div class="trm-card ">
    <article id="article-container" class="trm-publication">
    <p>[toc]</p>
<h1 id="Redis跳表实现详解"><a href="#Redis跳表实现详解" class="headerlink" title="Redis跳表实现详解"></a>Redis跳表实现详解</h1><p>跳表只在Redis的有序集合中用到了。</p>
<ul>
<li>什么场景下会需要用到跳表和红黑树</li>
<li>普通链表的查找复杂度，为什么双向链表可以降低查询复杂度</li>
</ul>
<h2 id="1-核心数据结构"><a href="#1-核心数据结构" class="headerlink" title="1. 核心数据结构"></a>1. 核心数据结构</h2><p><img src="https://obsidian-1311563466.cos.ap-guangzhou.myqcloud.com/obsidian/20250502160237837.png" alt="image.png"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="1-1-跳表节点"><a href="#1-1-跳表节点" class="headerlink" title="1.1 跳表节点"></a>1.1 跳表节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;                  <span class="comment">// 成员对象(键)</span></span><br><span class="line">    <span class="type">double</span> score;             <span class="comment">// 分值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>  <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>  <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;             <span class="comment">// 跨度</span></span><br><span class="line">    &#125; level[];                <span class="comment">// 柔性数组，每个节点的层</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-跳表结构"><a href="#1-2-跳表结构" class="headerlink" title="1.2 跳表结构"></a>1.2 跳表结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure>
<p><img src="https://obsidian-1311563466.cos.ap-guangzhou.myqcloud.com/obsidian/20250502160226956.png" alt="image.png"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="2-核心功能实现"><a href="#2-核心功能实现" class="headerlink" title="2. 核心功能实现"></a>2. 核心功能实现</h2><h3 id="2-1-创建跳表"><a href="#2-1-创建跳表" class="headerlink" title="2.1 创建跳表"></a>2.1 创建跳表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">zskiplistNode *<span class="title function_">zslCreateNode</span><span class="params">(<span class="type">int</span> level, <span class="type">double</span> score, sds ele)</span>&#123;</span><br><span class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zskiplist *<span class="title function_">zslCreate</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化表头节点，表头节点层数为ZSKIPLIST_MAXLEVEL=32</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++)&#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = null;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = null;</span><br><span class="line">    zsl-&gt;tail = null;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-层数随机化函数"><a href="#2-2-层数随机化函数" class="headerlink" title="2.2 层数随机化函数"></a>2.2 层数随机化函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">zslRandomLevel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level &lt; ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-函数详细解析"><a href="#2-2-1-函数详细解析" class="headerlink" title="2.2.1 函数详细解析"></a>2.2.1 函数详细解析</h4><h5 id="初始化层数"><a href="#初始化层数" class="headerlink" title="初始化层数"></a>初始化层数</h5><p>每个节点至少有1层（<code>level = 1</code>）。</p>
<h5 id="随机决定是否增加层数"><a href="#随机决定是否增加层数" class="headerlink" title="随机决定是否增加层数"></a>随机决定是否增加层数</h5><ul>
<li><code>random()</code> 生成一个随机数</li>
<li><code>&amp;0xFFFF</code> 对随机数进行位与操作，取低16位(0-65535)</li>
<li><code>ZSKIPLIST_P * 0xFFFF</code> 计算概率阈值(Redis中ZSKIPLIST_P&#x3D;0.25)</li>
<li>当随机数小于概率阈值时，层数加1</li>
</ul>
<h5 id="限制最大层数"><a href="#限制最大层数" class="headerlink" title="限制最大层数"></a>限制最大层数</h5><ul>
<li>如果生成的层数小于 <code>ZSKIPLIST_MAXLEVEL</code>(32)，则使用生成的值</li>
<li>否则使用 <code>ZSKIPLIST_MAXLEVEL</code> 作为上限</li>
</ul>
<h5 id="概率分析"><a href="#概率分析" class="headerlink" title="概率分析"></a>概率分析</h5><p>这个函数实现了几何分布，具有以下特性：</p>
<ul>
<li>每个节点至少有1层（概率为1）</li>
<li>有2层的概率是0.25（25%）</li>
<li>有3层的概率是0.25²（6.25%）</li>
<li>有4层的概率是0.25³（约1.56%）</li>
</ul>
<p>这种分布保证了：</p>
<ul>
<li>大多数节点只有少数几层，节省内存</li>
<li>少数节点有较多层，提供快速访问路径</li>
<li>理论上层数期望值为 1&#x2F;(1-p) &#x3D; 1&#x2F;(1-0.25) &#x3D; 4&#x2F;3 ≈ 1.33层</li>
</ul>
<h5 id="位操作说明"><a href="#位操作说明" class="headerlink" title="位操作说明"></a>位操作说明</h5><p>使用<code>random()&amp;0xFFFF</code>是为了：</p>
<ol>
<li>将随机数限制在固定范围(0-65535)</li>
<li>避免处理负数和浮点数计算</li>
<li>使用位操作比取模更高效</li>
</ol>
<h5 id="位操作示例"><a href="#位操作示例" class="headerlink" title="位操作示例"></a>位操作示例</h5><p><strong>例子1：random() &#x3D; 42949</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">十进制值: 42949</span><br><span class="line">二进制表示: 0000 0000 0000 1010 0111 1100 0101</span><br><span class="line">与 0xFFFF 进行位与:</span><br><span class="line">  0000 0000 0000 1010 0111 1100 0101  (42949)</span><br><span class="line">&amp; 0000 0000 0000 0000 1111 1111 1111  (0xFFFF)</span><br><span class="line">  --------------------------------</span><br><span class="line">  0000 0000 0000 0000 0111 1100 0101  (1985)</span><br></pre></td></tr></table></figure>

<p><strong>例子2：random() &#x3D; 98732</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">十进制值: 98732</span><br><span class="line">二进制表示: 0000 0000 0001 1000 0001 1101 1100</span><br><span class="line">与 0xFFFF 进行位与:</span><br><span class="line">  0000 0000 0001 1000 0001 1101 1100  (98732)</span><br><span class="line">&amp; 0000 0000 0000 0000 1111 1111 1111  (0xFFFF)</span><br><span class="line">  --------------------------------</span><br><span class="line">  0000 0000 0000 0000 0001 1101 1100  (476)</span><br></pre></td></tr></table></figure>

<p><strong>例子3：random() 返回 2147483647 (0x7FFFFFFF，32位有符号整数的最大值)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">十进制值: 2147483647</span><br><span class="line">二进制表示: 0111 1111 1111 1111 1111 1111 1111</span><br><span class="line">与 0xFFFF 进行位与:</span><br><span class="line">  0111 1111 1111 1111 1111 1111 1111  (2147483647)</span><br><span class="line">&amp; 0000 0000 0000 0000 1111 1111 1111  (0xFFFF)</span><br><span class="line">  --------------------------------</span><br><span class="line">  0000 0000 0000 0000 1111 1111 1111  (65535)</span><br></pre></td></tr></table></figure>

<p>结果：65535 (0xFFFF的十进制值)</p>
<h5 id="在随机层数中的应用"><a href="#在随机层数中的应用" class="headerlink" title="在随机层数中的应用"></a>在随机层数中的应用</h5><ol>
<li><strong>范围限制</strong>: 将随机数限制在0-65535之间</li>
<li><strong>概率计算</strong>: 与概率阈值比较(0.25*65535≈16383)<ul>
<li>随机值&lt;16383时(25%概率)，层数增加</li>
</ul>
</li>
<li><strong>简化</strong>: 使用位操作提高效率</li>
</ol>
<p>这种设计确保了跳表形成有效的”跳跃”特性，实现O(log n)的查找复杂度。</p>
<h3 id="2-3-插入操作"><a href="#2-3-插入操作" class="headerlink" title="2.3 插入操作"></a>2.3 插入操作</h3><p><img src="https://obsidian-1311563466.cos.ap-guangzhou.myqcloud.com/obsidian/20250502160407473.png" alt="image.png"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>因为可能会有score相等的情况所以还要增加一个比较字典续<br><code>while (x-&gt;level[i].forward &amp;&amp;</code><br>               <code>(x-&gt;level[i].forward-&gt;score &lt; score ||</code><br>                <code>(x-&gt;level[i].forward-&gt;score == score &amp;&amp;</code><br>                 <code>sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">zskiplistNode *<span class="title function_">zslInsert</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, sds ele)</span> &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="type">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">// 自上而下遍历每一层</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 初始化rank值</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在当前层查找合适的插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">               (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                 sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            rank[i] += x-&gt;level[i].span;  <span class="comment">// 累加跨度</span></span><br><span class="line">            x = x-&gt;level[i].forward;      <span class="comment">// 前进</span></span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;  <span class="comment">// 记录每一层插入位置的前驱节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 后续代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-插入操作的步骤解析"><a href="#3-插入操作的步骤解析" class="headerlink" title="3. 插入操作的步骤解析"></a>3. 插入操作的步骤解析</h2><p><img src="https://obsidian-1311563466.cos.ap-guangzhou.myqcloud.com/obsidian/20250502160157303.png" alt="image.png"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="3-1-查找插入位置"><a href="#3-1-查找插入位置" class="headerlink" title="3.1 查找插入位置"></a>3.1 查找插入位置</h3><p>首先，函数从跳表的最高层开始，自上而下查找新节点的插入位置：</p>
<ul>
<li><code>update</code>数组：记录每一层中新节点的前驱节点</li>
<li><code>rank</code>数组：记录每一层中前驱节点的排名</li>
</ul>
<p>查找过程中有两个关键操作：</p>
<ul>
<li>在每一层查找score值大于等于新节点的节点</li>
<li>如果score值相同，则比较成员(ele)的字典序</li>
</ul>
<h3 id="3-2-随机生成新节点的层数"><a href="#3-2-随机生成新节点的层数" class="headerlink" title="3.2 随机生成新节点的层数"></a>3.2 随机生成新节点的层数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">level = zslRandomLevel();</span><br><span class="line"><span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">        update[i] = zsl-&gt;header;</span><br><span class="line">        update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;level = level;  <span class="comment">// 更新跳表最大层数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果新节点的层数超过当前跳表的最大层数，则需要更新跳表的层数并初始化新增层的update和rank信息。</p>
<h3 id="3-3-创建新节点并设置指针关系"><a href="#3-3-创建新节点并设置指针关系" class="headerlink" title="3.3 创建新节点并设置指针关系"></a>3.3 创建新节点并设置指针关系</h3><p>&#x3D;&#x3D;如果新节点比所有节点都小那就是插入在头节点后面&#x3D;&#x3D;<br>&#x3D;&#x3D;如果找到了那就每层小于x的所有值中最大的那个&#x3D;&#x3D;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = zslCreateNode(level, score, ele);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置前进指针和跨度</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">    x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">    update[i]-&gt;level[i].forward = x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新跨度</span></span><br><span class="line">    x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">    update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分代码完成了新节点的插入和前进指针的设置，并更新了跨度值。跨度计算特别重要：</p>
<ul>
<li><code>rank[0]</code>是最底层前驱节点的排名</li>
<li><code>rank[i]</code>是第i层前驱节点的排名</li>
<li><code>rank[0] - rank[i]</code>表示从第i层前驱节点下降到最底层前驱节点需要跨越的节点数</li>
</ul>
<h3 id="3-4-更新高层的跨度"><a href="#3-4-更新高层的跨度" class="headerlink" title="3.4 更新高层的跨度"></a>3.4 更新高层的跨度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新高于新节点的那些层的跨度</span></span><br><span class="line"><span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">    update[i]-&gt;level[i].span++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于高于新节点的那些层，需要增加跨度以反映新节点的加入。</p>
<h3 id="3-5-设置后退指针"><a href="#3-5-设置后退指针" class="headerlink" title="3.5 设置后退指针"></a>3.5 设置后退指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置后退指针</span></span><br><span class="line">x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">    x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    zsl-&gt;tail = x;</span><br></pre></td></tr></table></figure>

<p>后退指针只在最底层维护，用于支持反向遍历。如果新节点是表尾，还需要更新跳表的tail指针。</p>
<h3 id="3-6-更新跳表节点计数并返回"><a href="#3-6-更新跳表节点计数并返回" class="headerlink" title="3.6 更新跳表节点计数并返回"></a>3.6 更新跳表节点计数并返回</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zsl-&gt;length++;  <span class="comment">// 跳表节点计数增一</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure>

<h2 id="4-Redis跳表中的跨度与排名作用分析"><a href="#4-Redis跳表中的跨度与排名作用分析" class="headerlink" title="4. Redis跳表中的跨度与排名作用分析"></a>4. Redis跳表中的跨度与排名作用分析</h2><p>跨度(span)和排名(rank)是Redis跳表实现中的关键概念，它们共同支持了有序集合(sorted set)中按排名查找和操作的功能。</p>
<h3 id="4-1-跨度-span-的定义与作用"><a href="#4-1-跨度-span-的定义与作用" class="headerlink" title="4.1 跨度(span)的定义与作用"></a>4.1 跨度(span)的定义与作用</h3><p>跨度存储在跳表节点的每个前向指针中，表示从当前节点沿着前向指针到达下一个节点时”跳过”的节点数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>  <span class="comment">// 前进指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> span;             <span class="comment">// 跨度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-1-跨度的核心作用"><a href="#4-1-1-跨度的核心作用" class="headerlink" title="4.1.1 跨度的核心作用"></a>4.1.1 跨度的核心作用</h4><ol>
<li><strong>支持按排名访问</strong>：<ul>
<li>跨度的累加可以精确计算节点的排名</li>
<li>跳表可以在O(log n)时间内定位到特定排名的节点</li>
</ul>
</li>
<li><strong>范围查询优化</strong>：<ul>
<li>在范围查询中，可以利用跨度快速确定范围内有多少个元素</li>
<li>避免不必要的节点访问</li>
</ul>
</li>
<li><strong>排名变化追踪</strong>：<ul>
<li>插入或删除节点时，通过更新跨度来反映排名变化</li>
<li>无需重新计算整个跳表的排名信息</li>
</ul>
</li>
</ol>
<h3 id="4-2-排名-rank-数组的作用"><a href="#4-2-排名-rank-数组的作用" class="headerlink" title="4.2 排名(rank)数组的作用"></a>4.2 排名(rank)数组的作用</h3><p><code>rank</code>数组是跳表操作中的临时变量，用于在插入和删除操作中跟踪每一层前驱节点的排名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> rank[ZSKIPLIST_MAXLEVEL];  <span class="comment">// 在zslInsert函数中</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-1-排名数组的主要用途"><a href="#4-2-1-排名数组的主要用途" class="headerlink" title="4.2.1 排名数组的主要用途"></a>4.2.1 排名数组的主要用途</h4><ol>
<li><strong>插入时计算新节点的确切位置</strong>：<ul>
<li>记录每层前驱节点的排名</li>
<li>用于计算新节点在各层的精确跨度</li>
</ul>
</li>
<li><strong>跨度更新依据</strong>：<ul>
<li><code>rank[0] - rank[i]</code>表示从第i层前驱下降到最底层前驱的节点数</li>
<li>用这个差值可以正确计算新节点的跨度</li>
</ul>
</li>
<li><strong>确保排名一致性</strong>：<ul>
<li>通过正确更新跨度，保证节点的排名在所有层级上一致</li>
</ul>
</li>
</ol>
<h3 id="4-3-跨度计算与更新实例"><a href="#4-3-跨度计算与更新实例" class="headerlink" title="4.3 跨度计算与更新实例"></a>4.3 跨度计算与更新实例</h3><p>在插入操作中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找阶段，累加跨度以计算排名</span></span><br><span class="line"><span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; ...) &#123;</span><br><span class="line">    rank[i] += x-&gt;level[i].span;  <span class="comment">// 累加跨度获取排名</span></span><br><span class="line">    x = x-&gt;level[i].forward;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入阶段，更新跨度</span></span><br><span class="line">x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新高层跨度</span></span><br><span class="line"><span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">    update[i]-&gt;level[i].span++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-实际应用场景"><a href="#4-4-实际应用场景" class="headerlink" title="4.4 实际应用场景"></a>4.4 实际应用场景</h3><ol>
<li><strong>排行榜功能</strong>：<ul>
<li>ZRANK命令：返回成员在有序集合中的排名</li>
<li>ZRANGE命令：返回指定排名范围内的成员</li>
</ul>
</li>
<li><strong>分页查询</strong>：<ul>
<li>根据排名高效实现数据分页</li>
<li>例如：获取排名100-120的用户</li>
</ul>
</li>
<li><strong>Top-N查询</strong>：<ul>
<li>快速获取分数最高&#x2F;最低的N个元素</li>
<li>无需扫描整个集合</li>
</ul>
</li>
</ol>
<h3 id="4-5-设计优势"><a href="#4-5-设计优势" class="headerlink" title="4.5 设计优势"></a>4.5 设计优势</h3><ol>
<li><strong>性能优化</strong>：O(log n)时间复杂度快速定位排名</li>
<li><strong>空间高效</strong>：只需每个前向指针额外存储一个整数</li>
<li><strong>实现简化</strong>：避免了复杂的树形结构平衡操作</li>
<li><strong>动态维护</strong>：插入删除时只需局部更新跨度</li>
</ol>
<p>跨度和排名的设计体现了Redis数据结构实现的精巧之处，通过巧妙的数据组织，在不增加结构复杂度的前提下实现了高效的排名操作。这一设计为Redis的有序集合提供了强大的排序和排名功能，使其在排行榜、计时统计等场景中有着出色的表现。</p>
<h2 id="5-Redis跳表插入中记录前驱节点的作用"><a href="#5-Redis跳表插入中记录前驱节点的作用" class="headerlink" title="5. Redis跳表插入中记录前驱节点的作用"></a>5. Redis跳表插入中记录前驱节点的作用</h2><p><code>update[i] = x;</code> 这一步骤是Redis跳表插入操作中的关键，它记录了将要插入的新节点在每一层的前驱节点。</p>
<h3 id="5-1-示例说明"><a href="#5-1-示例说明" class="headerlink" title="5.1 示例说明"></a>5.1 示例说明</h3><p>假设我们有一个跳表，包含以下节点及其分值(score)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Level 3: header --------------------------------------------------------&gt; 30</span><br><span class="line">Level 2: header ----------------&gt; 10 --------------&gt; 20 ---------------&gt; 30</span><br><span class="line">Level 1: header ------&gt; 5 ------&gt; 10 ------&gt; 15 ---&gt; 20 ------&gt; 25 ---&gt; 30</span><br><span class="line">Level 0: header -&gt; 3 -&gt; 5 -&gt; 7 -&gt; 10 -&gt; 12 -&gt; 15 -&gt; 17 -&gt; 20 -&gt; 23 -&gt; 25 -&gt; 30</span><br></pre></td></tr></table></figure>

<p>现在我们要插入一个新节点，分值为 13。</p>
<h4 id="5-1-1-找到前驱节点并填充update数组"><a href="#5-1-1-找到前驱节点并填充update数组" class="headerlink" title="5.1.1 找到前驱节点并填充update数组"></a>5.1.1 找到前驱节点并填充update数组</h4><p>从最高层(Level 3)开始向下搜索：</p>
<p><strong>Level 3:</strong></p>
<ul>
<li>从header开始，下一个节点是30，30 &gt; 13，停止</li>
<li><code>update[3] = header</code></li>
</ul>
<p><strong>Level 2:</strong></p>
<ul>
<li>从header开始，下一个是10，10 &lt; 13，前进</li>
<li>到达10，下一个是20，20 &gt; 13，停止</li>
<li><code>update[2] = 节点10</code></li>
</ul>
<p><strong>Level 1:</strong></p>
<ul>
<li>从10开始，下一个是15，15 &gt; 13，停止</li>
<li><code>update[1] = 节点10</code></li>
</ul>
<p><strong>Level 0:</strong></p>
<ul>
<li>从10开始，下一个是12，12 &lt; 13，前进</li>
<li>到达12，下一个是15，15 &gt; 13，停止</li>
<li><code>update[0] = 节点12</code></li>
</ul>
<p>最终update数组的值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update[3] = header</span><br><span class="line">update[2] = 节点10</span><br><span class="line">update[1] = 节点10</span><br><span class="line">update[0] = 节点12</span><br></pre></td></tr></table></figure>

<h4 id="5-1-2-随机生成新节点层数"><a href="#5-1-2-随机生成新节点层数" class="headerlink" title="5.1.2 随机生成新节点层数"></a>5.1.2 随机生成新节点层数</h4><p>假设随机生成的层数为2 (Level 0和Level 1)</p>
<h4 id="5-1-3-利用update数组插入新节点"><a href="#5-1-3-利用update数组插入新节点" class="headerlink" title="5.1.3 利用update数组插入新节点"></a>5.1.3 利用update数组插入新节点</h4><p>现在我们创建值为13的新节点，并需要将它插入到跳表中。这时update数组的作用就显现出来了：</p>
<p>对于Level 0:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x-&gt;level[<span class="number">0</span>].forward = update[<span class="number">0</span>]-&gt;level[<span class="number">0</span>].forward;  <span class="comment">// 新节点指向节点15</span></span><br><span class="line">update[<span class="number">0</span>]-&gt;level[<span class="number">0</span>].forward = x;  <span class="comment">// 节点12指向新节点</span></span><br></pre></td></tr></table></figure>

<p>对于Level 1:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x-&gt;level[<span class="number">1</span>].forward = update[<span class="number">1</span>]-&gt;level[<span class="number">1</span>].forward;  <span class="comment">// 新节点指向节点15</span></span><br><span class="line">update[<span class="number">1</span>]-&gt;level[<span class="number">1</span>].forward = x;  <span class="comment">// 节点10指向新节点</span></span><br></pre></td></tr></table></figure>

<p>插入后的跳表结构变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Level 3: header --------------------------------------------------------&gt; 30</span><br><span class="line">Level 2: header ----------------&gt; 10 --------------&gt; 20 ---------------&gt; 30</span><br><span class="line">Level 1: header ------&gt; 5 ------&gt; 10 ------&gt; 13 ---&gt; 15 ---&gt; 20 ------&gt; 25 ---&gt; 30</span><br><span class="line">Level 0: header -&gt; 3 -&gt; 5 -&gt; 7 -&gt; 10 -&gt; 12 -&gt; 13 -&gt; 15 -&gt; 17 -&gt; 20 -&gt; 23 -&gt; 25 -&gt; 30</span><br></pre></td></tr></table></figure>

<h3 id="5-2-update数组的关键作用"><a href="#5-2-update数组的关键作用" class="headerlink" title="5.2 update数组的关键作用"></a>5.2 update数组的关键作用</h3><p>图中这种向下查找的过程就需要每层查找的时候都保留前驱，<br>第一层是header<br>第二层y<br>第三层w<br><img src="https://obsidian-1311563466.cos.ap-guangzhou.myqcloud.com/obsidian/20250502160000568.png" alt="image.png"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'><br>&#x3D;&#x3D;图片来自&#x3D;&#x3D; <a target="_blank" rel="noopener" href="https://blog.csdn.net/Zhouzi_heng/article/details/127554294">https://blog.csdn.net/Zhouzi_heng/article/details/127554294</a></p>
<ol>
<li><strong>连接前后节点</strong>：<ul>
<li>通过update数组，我们知道每层中新节点应该插入在哪个节点之后</li>
<li>这使得我们可以正确连接前后节点的指针，保持跳表的有序性</li>
</ul>
</li>
<li><strong>更新跨度值</strong>：<ul>
<li>利用update数组中记录的前驱节点，可以更新这些节点的span值</li>
<li>同时设置新节点的span值，确保排名计算的正确性</li>
</ul>
</li>
<li><strong>设置后退指针</strong>：<ul>
<li>最底层的前驱节点(update[0])用于设置新节点的后退指针</li>
<li><code>x-&gt;backward = update[0]</code></li>
</ul>
</li>
<li><strong>处理边界情况</strong>：<ul>
<li>如果新节点层数高于当前跳表最大层数，通过update可以连接新增层</li>
<li>如果新节点将成为表尾，可以通过update判断并更新tail指针</li>
</ul>
</li>
</ol>
<p>没有update数组，插入操作将变得非常复杂，可能需要多次遍历跳表来找到每一层的正确插入位置。通过使用update数组，我们只需一次遍历就可以记录所有必要信息，大大提高了插入效率。</p>
<h2 id="6-删除操作"><a href="#6-删除操作" class="headerlink" title="6. 删除操作"></a>6. 删除操作</h2><p><img src="https://obsidian-1311563466.cos.ap-guangzhou.myqcloud.com/obsidian/20250502160207683.png" alt="image.png"  data-tag='post-image' onload='this.onload=null;this.style.opacity=1;' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>删除操作需要：</p>
<ul>
<li>找到目标节点前驱</li>
<li>调整指针和跨度</li>
<li>可能需要降低跳表最大层数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">zslDelete</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, sds ele, zskiplistNode **node)</span> &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最高层开始查找目标节点的前驱</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 查找前驱节点</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">               (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                 sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x; <span class="comment">// 记录每层的前驱节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到目标节点（如果存在）</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到目标节点，执行删除操作</span></span><br><span class="line">        zslDeleteNode(zsl, x, update);</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">            zslFreeNode(x); <span class="comment">// 如果不需要返回被删除节点，则释放内存</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *node = x;      <span class="comment">// 否则通过node参数返回被删除节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没找到目标节点，返回0表示删除失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际执行节点删除的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整所有层的前进指针和跨度</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</span><br><span class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</span><br><span class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>; <span class="comment">// 不直接相连的层，只需减少跨度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整后退指针</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zsl-&gt;tail = x-&gt;backward;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果删除的是最高层的节点，可能需要降低跳表的最大层数</span></span><br><span class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</span><br><span class="line">        zsl-&gt;level--;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 跳表节点计数减一</span></span><br><span class="line">    zsl-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-删除操作的关键步骤"><a href="#6-1-删除操作的关键步骤" class="headerlink" title="6.1 删除操作的关键步骤"></a>6.1 删除操作的关键步骤</h3><ol>
<li><p><strong>查找目标节点</strong>：</p>
<ul>
<li>和插入操作类似，从最高层向下查找</li>
<li>记录每一层的前驱节点到update数组</li>
</ul>
</li>
<li><p><strong>调整指针</strong>：</p>
<ul>
<li>对于每一层，修改前驱节点的forward指针，绕过被删除节点</li>
<li>调整后继节点的backward指针，保持双向链表特性</li>
</ul>
</li>
<li><p><strong>更新跨度</strong>：</p>
<ul>
<li>对于直接相连的层：<code>update[i]-&gt;level[i].span += x-&gt;level[i].span - 1</code></li>
<li>对于不直接相连的层：<code>update[i]-&gt;level[i].span -= 1</code></li>
</ul>
</li>
<li><p><strong>处理特殊情况</strong>：</p>
<ul>
<li>如果删除的是尾节点，更新tail指针</li>
<li>如果删除后最高层没有节点，降低跳表的level值</li>
</ul>
</li>
</ol>
<h3 id="6-2-删除操作的复杂度"><a href="#6-2-删除操作的复杂度" class="headerlink" title="6.2 删除操作的复杂度"></a>6.2 删除操作的复杂度</h3><ul>
<li>时间复杂度：O(log N)，主要在于查找目标节点的过程</li>
<li>空间复杂度：O(1)，仅使用常数额外空间（update数组）</li>
</ul>
<h2 id="7-查找操作"><a href="#7-查找操作" class="headerlink" title="7. 查找操作"></a>7. 查找操作</h2><p>查找从最高层开始，逐层降低，每一层都尽可能向前搜索。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">zskiplistNode *<span class="title function_">zslFind</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, sds ele)</span> &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从最高层开始查找</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 在当前层尽可能前进</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">               (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                 sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 现在x-&gt;level[0].forward可能是我们要找的节点</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x; <span class="comment">// 找到目标节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-1-查找操作的原理"><a href="#7-1-查找操作的原理" class="headerlink" title="7.1 查找操作的原理"></a>7.1 查找操作的原理</h3><ol>
<li><p><strong>多层跳跃</strong>：</p>
<ul>
<li>从最高层开始查找，利用高层快速跳过大量节点</li>
<li>当无法在当前层继续前进时，降低一层继续查找</li>
</ul>
</li>
<li><p><strong>匹配条件</strong>：</p>
<ul>
<li>首先比较score值</li>
<li>如果score相同，则比较成员对象(ele)</li>
</ul>
</li>
<li><p><strong>查找策略</strong>：</p>
<ul>
<li>贪心策略：在每一层尽可能向前，直到下一个节点的score大于等于目标score</li>
<li>当到达最底层时，检查最后到达的节点是否为目标节点</li>
</ul>
</li>
</ol>
<h3 id="7-2-查找效率分析"><a href="#7-2-查找效率分析" class="headerlink" title="7.2 查找效率分析"></a>7.2 查找效率分析</h3><ul>
<li><p><strong>平均时间复杂度</strong>：O(log N)</p>
<ul>
<li>高层作为快速通道，大大减少了需要访问的节点数</li>
<li>层数分布的随机性保证了查找路径的平均长度是对数级的</li>
</ul>
</li>
<li><p><strong>最坏时间复杂度</strong>：仍为O(log N)</p>
<ul>
<li>即使在最不利情况下，层数的随机分布也能保证一定的性能</li>
</ul>
</li>
<li><p><strong>空间开销与查找速度的平衡</strong>：</p>
<ul>
<li>通过概率分布控制节点的平均层数为常数(约1.33)</li>
<li>在空间效率和查找速度之间取得良好平衡</li>
</ul>
</li>
</ul>
<h2 id="8-按排名查找"><a href="#8-按排名查找" class="headerlink" title="8. 按排名查找"></a>8. 按排名查找</h2><p>利用跨度(span)快速定位到特定排名的节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">zskiplistNode *<span class="title function_">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="type">unsigned</span> <span class="type">long</span> rank)</span> &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> traversed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从最高层开始查找</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 尝试在当前层前进，只要不超过目标排名</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank) &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果已经到达目标排名，返回该节点</span></span><br><span class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 目标排名不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-按排名查找的实现原理"><a href="#8-1-按排名查找的实现原理" class="headerlink" title="8.1 按排名查找的实现原理"></a>8.1 按排名查找的实现原理</h3><ol>
<li><p><strong>利用跨度累加</strong>：</p>
<ul>
<li>维护一个traversed变量，记录已经跨越的节点数</li>
<li>每次前进时，将当前指针的span值加到traversed上</li>
</ul>
</li>
<li><p><strong>贪心策略</strong>：</p>
<ul>
<li>在每一层尽可能前进，直到再前进一步就会超过目标排名</li>
<li>然后降低一层继续查找</li>
</ul>
</li>
<li><p><strong>排名匹配</strong>：</p>
<ul>
<li>如果traversed正好等于目标rank，说明找到了对应排名的节点</li>
<li>注意：Redis的排名是从1开始的，而不是从0开始</li>
</ul>
</li>
</ol>
<h3 id="8-2-按排名查找的应用"><a href="#8-2-按排名查找的应用" class="headerlink" title="8.2 按排名查找的应用"></a>8.2 按排名查找的应用</h3><ol>
<li><p><strong>ZRANGE命令实现</strong>：</p>
<ul>
<li>获取有序集合中指定排名范围的元素</li>
<li>首先找到起始排名的节点，然后沿着level[0]前进指定步数</li>
</ul>
</li>
<li><p><strong>ZRANK命令实现</strong>：</p>
<ul>
<li>获取指定成员在有序集合中的排名</li>
<li>使用类似的遍历方式，但是查找特定成员而非特定排名</li>
</ul>
</li>
</ol>
<h3 id="8-3-效率分析"><a href="#8-3-效率分析" class="headerlink" title="8.3 效率分析"></a>8.3 效率分析</h3><ul>
<li><strong>时间复杂度</strong>：O(log N)，与普通查找操作相同</li>
<li><strong>关键优化</strong>：跨度(span)的设计使得跳表可以在不增加结构复杂度的情况下，高效支持按排名查找操作</li>
</ul>
<h2 id="附（问题）"><a href="#附（问题）" class="headerlink" title="附（问题）"></a>附（问题）</h2><p>跳表只在Redis的有序集合中用到了。以下是关于跳表、红黑树和链表的一些常见问题解答。</p>
<h3 id="9-1-什么场景下会需要用到跳表和红黑树？"><a href="#9-1-什么场景下会需要用到跳表和红黑树？" class="headerlink" title="9.1 什么场景下会需要用到跳表和红黑树？"></a>9.1 什么场景下会需要用到跳表和红黑树？</h3><h4 id="9-1-1-跳表适用场景"><a href="#9-1-1-跳表适用场景" class="headerlink" title="9.1.1 跳表适用场景"></a>9.1.1 跳表适用场景</h4><ol>
<li><p><strong>范围查询频繁的场景</strong>：</p>
<ul>
<li>跳表对范围查询非常友好，可以很容易地找到某个范围内的所有元素</li>
<li>例如：Redis的ZRANGEBYSCORE命令，查找分数在某个范围内的所有元素</li>
</ul>
</li>
<li><p><strong>需要按序遍历的场景</strong>：</p>
<ul>
<li>跳表的底层是一个有序链表，可以方便地进行顺序遍历</li>
<li>例如：获取排名前10的玩家</li>
</ul>
</li>
<li><p><strong>经常需要插入和删除的有序数据结构</strong>：</p>
<ul>
<li>跳表插入删除的平均时间复杂度为O(log n)，且实现相对简单</li>
<li>不需要像平衡树那样进行复杂的旋转操作</li>
</ul>
</li>
<li><p><strong>内存空间相对宽裕的场景</strong>：</p>
<ul>
<li>跳表需要存储多个层次的索引，空间消耗相对较大</li>
</ul>
</li>
<li><p><strong>实现简单性优先的场景</strong>：</p>
<ul>
<li>跳表比红黑树更容易实现和调试</li>
<li>代码可维护性更高</li>
</ul>
</li>
</ol>
<h4 id="9-1-2-红黑树适用场景"><a href="#9-1-2-红黑树适用场景" class="headerlink" title="9.1.2 红黑树适用场景"></a>9.1.2 红黑树适用场景</h4><ol>
<li><p><strong>内存敏感的场景</strong>：</p>
<ul>
<li>红黑树比跳表更节省内存</li>
<li>例如：嵌入式系统或内存受限的环境</li>
</ul>
</li>
<li><p><strong>单点查询频繁的场景</strong>：</p>
<ul>
<li>红黑树的查找性能非常稳定，最坏情况下仍为O(log n)</li>
<li>例如：各种Map和Set的实现（如C++ STL中的map, set）</li>
</ul>
</li>
<li><p><strong>绝对平衡要求高的场景</strong>：</p>
<ul>
<li>红黑树保证最坏情况下的平衡性，而跳表是概率平衡</li>
<li>例如：实时系统需要稳定的响应时间</li>
</ul>
</li>
<li><p><strong>不需要范围查询的有序数据结构</strong>：</p>
<ul>
<li>如果主要是查找、插入、删除单个元素，红黑树可能更合适</li>
</ul>
</li>
</ol>
<h4 id="9-1-3-Redis选择跳表而非红黑树的原因"><a href="#9-1-3-Redis选择跳表而非红黑树的原因" class="headerlink" title="9.1.3 Redis选择跳表而非红黑树的原因"></a>9.1.3 Redis选择跳表而非红黑树的原因</h4><ol>
<li><p><strong>范围操作效率</strong>：</p>
<ul>
<li>在Redis有序集合中，范围操作非常常见（如ZRANGE, ZRANGEBYSCORE）</li>
<li>跳表在范围查询上性能优于红黑树</li>
</ul>
</li>
<li><p><strong>实现简单性</strong>：</p>
<ul>
<li>跳表的实现远比红黑树简单</li>
<li>更少的代码意味着更少的bug和更容易的维护</li>
</ul>
</li>
<li><p><strong>内存布局更好</strong>：</p>
<ul>
<li>跳表的内存布局更连续，对缓存更友好</li>
<li>可以灵活控制索引密度（通过调整层数概率）</li>
</ul>
</li>
<li><p><strong>更易于并发控制</strong>：</p>
<ul>
<li>跳表的结构使得并发插入删除相对容易实现</li>
<li>虽然Redis是单线程模型，但这种特性在设计上仍有价值</li>
</ul>
</li>
</ol>
<h3 id="9-2-普通链表的查找复杂度，为什么双向链表可以降低查询复杂度？"><a href="#9-2-普通链表的查找复杂度，为什么双向链表可以降低查询复杂度？" class="headerlink" title="9.2 普通链表的查找复杂度，为什么双向链表可以降低查询复杂度？"></a>9.2 普通链表的查找复杂度，为什么双向链表可以降低查询复杂度？</h3><h4 id="9-2-1-普通链表的查找复杂度"><a href="#9-2-1-普通链表的查找复杂度" class="headerlink" title="9.2.1 普通链表的查找复杂度"></a>9.2.1 普通链表的查找复杂度</h4><ol>
<li><p><strong>单向链表</strong>：</p>
<ul>
<li>时间复杂度：O(n)，必须从头开始遍历</li>
<li>只能朝一个方向遍历</li>
<li>空间复杂度：每个节点额外存储一个指针</li>
</ul>
</li>
<li><p><strong>双向链表</strong>：</p>
<ul>
<li>时间复杂度：对于随机访问仍然是O(n)</li>
<li>但可以从两个方向遍历</li>
<li>空间复杂度：每个节点额外存储两个指针</li>
</ul>
</li>
</ol>
<h4 id="9-2-2-双向链表如何降低查询复杂度"><a href="#9-2-2-双向链表如何降低查询复杂度" class="headerlink" title="9.2.2 双向链表如何降低查询复杂度"></a>9.2.2 双向链表如何降低查询复杂度</h4><p>双向链表本身对于随机元素的查询复杂度仍然是O(n)，但在特定场景下可以提高效率：</p>
<ol>
<li><p><strong>已知位置附近的查询</strong>：</p>
<ul>
<li>如果知道目标元素大约在链表的什么位置，可以选择从头或尾开始遍历</li>
<li>例如：元素可能在链表尾部附近，从尾部开始查找更高效</li>
</ul>
</li>
<li><p><strong>频繁访问两端元素</strong>：</p>
<ul>
<li>双向链表可以O(1)时间访问头尾元素</li>
<li>例如：实现队列或栈时非常高效</li>
</ul>
</li>
<li><p><strong>插入和删除操作</strong>：</p>
<ul>
<li>如果已经有指向节点的指针，可以O(1)时间完成插入和删除</li>
<li>不需要查找前驱节点，降低了操作复杂度</li>
</ul>
</li>
<li><p><strong>双向遍历需求</strong>：</p>
<ul>
<li>某些算法需要同时向前和向后查看元素</li>
<li>例如：LRU缓存的实现</li>
</ul>
</li>
</ol>
<p>在Redis的跳表实现中，双向链表特性（backward指针）主要用于：</p>
<ul>
<li>反向遍历有序集合</li>
<li>在删除节点时更容易更新前驱节点</li>
<li>支持ZREVRANGE等反向遍历命令</li>
</ul>
<h4 id="9-2-3-相关问题"><a href="#9-2-3-相关问题" class="headerlink" title="9.2.3 相关问题"></a>9.2.3 相关问题</h4><h5 id="1-跳表与平衡树相比有什么优势和劣势？"><a href="#1-跳表与平衡树相比有什么优势和劣势？" class="headerlink" title="1. 跳表与平衡树相比有什么优势和劣势？"></a>1. 跳表与平衡树相比有什么优势和劣势？</h5><p><strong>优势</strong>：</p>
<ul>
<li>实现更简单，代码更易维护</li>
<li>插入和删除不需要复杂的平衡操作</li>
<li>范围查询效率高</li>
<li>空间利用更灵活（可以通过调整概率控制索引密度）</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li>内存占用通常更高</li>
<li>平衡性基于概率，不是严格保证</li>
<li>不像某些特殊的树结构那样可以针对特定应用场景高度优化</li>
</ul>
<h5 id="2-为什么Redis不使用B-树作为有序集合的实现？"><a href="#2-为什么Redis不使用B-树作为有序集合的实现？" class="headerlink" title="2. 为什么Redis不使用B+树作为有序集合的实现？"></a>2. 为什么Redis不使用B+树作为有序集合的实现？</h5><p>B+树是数据库系统中常用的数据结构，但Redis选择跳表而非B+树的原因包括：</p>
<ul>
<li><strong>内存vs磁盘</strong>：B+树主要优化磁盘访问，而Redis是内存数据库</li>
<li><strong>实现复杂度</strong>：B+树实现比跳表复杂得多</li>
<li><strong>单元素操作</strong>：在纯内存环境中，跳表的单元素操作不比B+树慢</li>
<li><strong>代码可维护性</strong>：跳表的代码更简洁，更易于维护</li>
</ul>
<h5 id="3-跳表的空间复杂度是多少？"><a href="#3-跳表的空间复杂度是多少？" class="headerlink" title="3. 跳表的空间复杂度是多少？"></a>3. 跳表的空间复杂度是多少？</h5><ul>
<li><strong>期望空间复杂度</strong>：O(n)</li>
<li>更准确地说，大约需要2n个指针（约1.33n用于索引层，n用于基本链表）</li>
<li>跳表的空间开销主要在于索引节点</li>
<li>使用p&#x3D;1&#x2F;4的层级概率，平均每个节点的指针数约为1.33</li>
</ul>
<h5 id="4-如何优化跳表以减少内存使用？"><a href="#4-如何优化跳表以减少内存使用？" class="headerlink" title="4. 如何优化跳表以减少内存使用？"></a>4. 如何优化跳表以减少内存使用？</h5><ol>
<li><p><strong>调整层数概率</strong>：</p>
<ul>
<li>降低p值（如从1&#x2F;4降至1&#x2F;8）可以减少索引层数</li>
<li>但会略微增加查找时间</li>
</ul>
</li>
<li><p><strong>压缩技术</strong>：</p>
<ul>
<li>对于字符串类型的键，可以使用前缀压缩</li>
<li>共享公共前缀减少内存使用</li>
</ul>
</li>
<li><p><strong>节点结构优化</strong>：</p>
<ul>
<li>使用柔性数组存储层级信息（Redis已采用）</li>
<li>小元素可以考虑内联存储</li>
</ul>
</li>
<li><p><strong>索引稀疏化</strong>：</p>
<ul>
<li>不是每个节点都创建索引，而是每k个节点创建一个</li>
<li>类似于跳表和B树的混合体</li>
</ul>
</li>
</ol>
<h5 id="5-跳表在并发环境下的表现如何？"><a href="#5-跳表在并发环境下的表现如何？" class="headerlink" title="5. 跳表在并发环境下的表现如何？"></a>5. 跳表在并发环境下的表现如何？</h5><p>虽然Redis主要是单线程模型，但跳表在并发环境中有以下特点：</p>
<ol>
<li><p><strong>并发友好结构</strong>：</p>
<ul>
<li>跳表的结构使其比平衡树更容易实现无锁操作</li>
<li>插入时只影响局部节点，不会导致全局重平衡</li>
</ul>
</li>
<li><p><strong>锁粒度</strong>：</p>
<ul>
<li>理论上可以实现细粒度锁，只锁定需要修改的部分</li>
<li>不同级别的锁可以分离（例如对高层索引和数据层使用不同的锁）</li>
</ul>
</li>
<li><p><strong>读写分离</strong>：</p>
<ul>
<li>读操作可以与写操作并发执行</li>
<li>因为查找过程不需要修改跳表结构</li>
</ul>
</li>
<li><p><strong>无锁实现可能性</strong>：</p>
<ul>
<li>跳表相对容易实现无锁版本（使用CAS操作）</li>
<li>相比之下，无锁红黑树非常复杂</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://tech.youzan.com/redisyuan-ma-jie-xi/">https://tech.youzan.com/redisyuan-ma-jie-xi/</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Zhouzi_heng/article/details/127554294">https://blog.csdn.net/Zhouzi_heng/article/details/127554294</a></li>
<li>《redis设计与实现》</li>
</ol>

</article>
    
    

</div>
<div class="trm-post-next-prev row">
    <div class="col-lg-12">
        <!-- title -->
        <h5 class="trm-title-with-divider">
            其他文章
            <span data-number="02"></span>
        </h5>
    </div>
    
        <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation">
        <a href="/2025/05/03/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E5%85%B8/" class="trm-cover-frame trm-anima-link">
            
            
                <img alt="cover" class="no-fancybox" src="/img/block.jpg">
            
        </a>
        
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" /categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
                    源码分析
                </a>
            </div>
            <h5>
                <a href="/2025/05/03/Redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E5%85%B8/" class="trm-anima-link">
                    categories
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>25/05/03</li>
                <li>13:25</li>
                
                
            </ul>
        </div>
    </div>
</div>
    
    
        <div class="col-lg-6">
    <div class="trm-blog-card trm-scroll-animation">
        <a href="/2025/03/21/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/" class="trm-cover-frame trm-anima-link">
            
            
                <img alt="cover" class="no-fancybox" src="/img/block.jpg">
            
        </a>
        
        <div class="trm-card-descr">
            <div class="trm-label trm-category trm-mb-20">
                <a href=" /categories/%E5%85%B6%E4%BB%96/">
                    其他
                </a>
            </div>
            <h5>
                <a href="/2025/03/21/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/" class="trm-anima-link">
                    互联网大厂技术博客地址总结
                </a>
            </h5>
            <div class="trm-divider trm-mb-20 trm-mt-20"></div>
            <ul class="trm-card-data trm-label">
                <li>25/03/21</li>
                <li>12:00</li>
                
                
            </ul>
        </div>
    </div>
</div>
    
</div>

    



                    <div class="trm-divider footer-divider"></div>

                    <!-- footer -->
                    <footer class="trm-footer-card trm-scroll-animation">

    

    
        <div class="trm-footer-item">
            <span>© 2024 - 2025</span>
            <span class="footer-separator"data-separator=" · "></span>
            <span class="trm-accent-color">Jerry</span>
        </div>
    

    
        <div class="trm-footer-item">
            <span>
                由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.3.0
            </span>
            <span class="footer-separator" data-separator=" | "></span>
            <span> 
                主题 - 
                <a rel="noopener" href='https://github.com/MaLuns/hexo-theme-async' target='_blank'>Async</a>
                v2.2.4
            </span>
        </div>
      

    
        <div class="trm-footer-item blog-run-long"></div>
     

     
</footer>
                    <!-- footer end -->

                </div>
            </div>
        </div>
    </div>
</div>
            <!-- body end -->

            

    <div id="post-toc" class="trm-post-toc">
      <div class="trm-post-toc-header">
        目录导航
				<span id="post-toc-top">
					置顶
				</span>
      </div>
      <div class="trm-post-toc-content">
        <ol class="trm-toc"><li class="trm-toc-item trm-toc-level-1" title="Redis跳表实现详解"><a rel="nofollow" class="trm-toc-link" href="#Redis跳表实现详解"><span class="trm-toc-text">Redis跳表实现详解</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-2" title="1. 核心数据结构"><a rel="nofollow" class="trm-toc-link" href="#1-核心数据结构"><span class="trm-toc-text">1. 核心数据结构</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="1.1 跳表节点"><a rel="nofollow" class="trm-toc-link" href="#1-1-跳表节点"><span class="trm-toc-text">1.1 跳表节点</span></a></li><li class="trm-toc-item trm-toc-level-3" title="1.2 跳表结构"><a rel="nofollow" class="trm-toc-link" href="#1-2-跳表结构"><span class="trm-toc-text">1.2 跳表结构</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="2. 核心功能实现"><a rel="nofollow" class="trm-toc-link" href="#2-核心功能实现"><span class="trm-toc-text">2. 核心功能实现</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="2.1 创建跳表"><a rel="nofollow" class="trm-toc-link" href="#2-1-创建跳表"><span class="trm-toc-text">2.1 创建跳表</span></a></li><li class="trm-toc-item trm-toc-level-3" title="2.2 层数随机化函数"><a rel="nofollow" class="trm-toc-link" href="#2-2-层数随机化函数"><span class="trm-toc-text">2.2 层数随机化函数</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-4" title="2.2.1 函数详细解析"><a rel="nofollow" class="trm-toc-link" href="#2-2-1-函数详细解析"><span class="trm-toc-text">2.2.1 函数详细解析</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-5" title="初始化层数"><a rel="nofollow" class="trm-toc-link" href="#初始化层数"><span class="trm-toc-text">初始化层数</span></a></li><li class="trm-toc-item trm-toc-level-5" title="随机决定是否增加层数"><a rel="nofollow" class="trm-toc-link" href="#随机决定是否增加层数"><span class="trm-toc-text">随机决定是否增加层数</span></a></li><li class="trm-toc-item trm-toc-level-5" title="限制最大层数"><a rel="nofollow" class="trm-toc-link" href="#限制最大层数"><span class="trm-toc-text">限制最大层数</span></a></li><li class="trm-toc-item trm-toc-level-5" title="概率分析"><a rel="nofollow" class="trm-toc-link" href="#概率分析"><span class="trm-toc-text">概率分析</span></a></li><li class="trm-toc-item trm-toc-level-5" title="位操作说明"><a rel="nofollow" class="trm-toc-link" href="#位操作说明"><span class="trm-toc-text">位操作说明</span></a></li><li class="trm-toc-item trm-toc-level-5" title="位操作示例"><a rel="nofollow" class="trm-toc-link" href="#位操作示例"><span class="trm-toc-text">位操作示例</span></a></li><li class="trm-toc-item trm-toc-level-5" title="在随机层数中的应用"><a rel="nofollow" class="trm-toc-link" href="#在随机层数中的应用"><span class="trm-toc-text">在随机层数中的应用</span></a></li></ol></li></ol></li><li class="trm-toc-item trm-toc-level-3" title="2.3 插入操作"><a rel="nofollow" class="trm-toc-link" href="#2-3-插入操作"><span class="trm-toc-text">2.3 插入操作</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="3. 插入操作的步骤解析"><a rel="nofollow" class="trm-toc-link" href="#3-插入操作的步骤解析"><span class="trm-toc-text">3. 插入操作的步骤解析</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="3.1 查找插入位置"><a rel="nofollow" class="trm-toc-link" href="#3-1-查找插入位置"><span class="trm-toc-text">3.1 查找插入位置</span></a></li><li class="trm-toc-item trm-toc-level-3" title="3.2 随机生成新节点的层数"><a rel="nofollow" class="trm-toc-link" href="#3-2-随机生成新节点的层数"><span class="trm-toc-text">3.2 随机生成新节点的层数</span></a></li><li class="trm-toc-item trm-toc-level-3" title="3.3 创建新节点并设置指针关系"><a rel="nofollow" class="trm-toc-link" href="#3-3-创建新节点并设置指针关系"><span class="trm-toc-text">3.3 创建新节点并设置指针关系</span></a></li><li class="trm-toc-item trm-toc-level-3" title="3.4 更新高层的跨度"><a rel="nofollow" class="trm-toc-link" href="#3-4-更新高层的跨度"><span class="trm-toc-text">3.4 更新高层的跨度</span></a></li><li class="trm-toc-item trm-toc-level-3" title="3.5 设置后退指针"><a rel="nofollow" class="trm-toc-link" href="#3-5-设置后退指针"><span class="trm-toc-text">3.5 设置后退指针</span></a></li><li class="trm-toc-item trm-toc-level-3" title="3.6 更新跳表节点计数并返回"><a rel="nofollow" class="trm-toc-link" href="#3-6-更新跳表节点计数并返回"><span class="trm-toc-text">3.6 更新跳表节点计数并返回</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="4. Redis跳表中的跨度与排名作用分析"><a rel="nofollow" class="trm-toc-link" href="#4-Redis跳表中的跨度与排名作用分析"><span class="trm-toc-text">4. Redis跳表中的跨度与排名作用分析</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="4.1 跨度(span)的定义与作用"><a rel="nofollow" class="trm-toc-link" href="#4-1-跨度-span-的定义与作用"><span class="trm-toc-text">4.1 跨度(span)的定义与作用</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-4" title="4.1.1 跨度的核心作用"><a rel="nofollow" class="trm-toc-link" href="#4-1-1-跨度的核心作用"><span class="trm-toc-text">4.1.1 跨度的核心作用</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-3" title="4.2 排名(rank)数组的作用"><a rel="nofollow" class="trm-toc-link" href="#4-2-排名-rank-数组的作用"><span class="trm-toc-text">4.2 排名(rank)数组的作用</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-4" title="4.2.1 排名数组的主要用途"><a rel="nofollow" class="trm-toc-link" href="#4-2-1-排名数组的主要用途"><span class="trm-toc-text">4.2.1 排名数组的主要用途</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-3" title="4.3 跨度计算与更新实例"><a rel="nofollow" class="trm-toc-link" href="#4-3-跨度计算与更新实例"><span class="trm-toc-text">4.3 跨度计算与更新实例</span></a></li><li class="trm-toc-item trm-toc-level-3" title="4.4 实际应用场景"><a rel="nofollow" class="trm-toc-link" href="#4-4-实际应用场景"><span class="trm-toc-text">4.4 实际应用场景</span></a></li><li class="trm-toc-item trm-toc-level-3" title="4.5 设计优势"><a rel="nofollow" class="trm-toc-link" href="#4-5-设计优势"><span class="trm-toc-text">4.5 设计优势</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="5. Redis跳表插入中记录前驱节点的作用"><a rel="nofollow" class="trm-toc-link" href="#5-Redis跳表插入中记录前驱节点的作用"><span class="trm-toc-text">5. Redis跳表插入中记录前驱节点的作用</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="5.1 示例说明"><a rel="nofollow" class="trm-toc-link" href="#5-1-示例说明"><span class="trm-toc-text">5.1 示例说明</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-4" title="5.1.1 找到前驱节点并填充update数组"><a rel="nofollow" class="trm-toc-link" href="#5-1-1-找到前驱节点并填充update数组"><span class="trm-toc-text">5.1.1 找到前驱节点并填充update数组</span></a></li><li class="trm-toc-item trm-toc-level-4" title="5.1.2 随机生成新节点层数"><a rel="nofollow" class="trm-toc-link" href="#5-1-2-随机生成新节点层数"><span class="trm-toc-text">5.1.2 随机生成新节点层数</span></a></li><li class="trm-toc-item trm-toc-level-4" title="5.1.3 利用update数组插入新节点"><a rel="nofollow" class="trm-toc-link" href="#5-1-3-利用update数组插入新节点"><span class="trm-toc-text">5.1.3 利用update数组插入新节点</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-3" title="5.2 update数组的关键作用"><a rel="nofollow" class="trm-toc-link" href="#5-2-update数组的关键作用"><span class="trm-toc-text">5.2 update数组的关键作用</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="6. 删除操作"><a rel="nofollow" class="trm-toc-link" href="#6-删除操作"><span class="trm-toc-text">6. 删除操作</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="6.1 删除操作的关键步骤"><a rel="nofollow" class="trm-toc-link" href="#6-1-删除操作的关键步骤"><span class="trm-toc-text">6.1 删除操作的关键步骤</span></a></li><li class="trm-toc-item trm-toc-level-3" title="6.2 删除操作的复杂度"><a rel="nofollow" class="trm-toc-link" href="#6-2-删除操作的复杂度"><span class="trm-toc-text">6.2 删除操作的复杂度</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="7. 查找操作"><a rel="nofollow" class="trm-toc-link" href="#7-查找操作"><span class="trm-toc-text">7. 查找操作</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="7.1 查找操作的原理"><a rel="nofollow" class="trm-toc-link" href="#7-1-查找操作的原理"><span class="trm-toc-text">7.1 查找操作的原理</span></a></li><li class="trm-toc-item trm-toc-level-3" title="7.2 查找效率分析"><a rel="nofollow" class="trm-toc-link" href="#7-2-查找效率分析"><span class="trm-toc-text">7.2 查找效率分析</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="8. 按排名查找"><a rel="nofollow" class="trm-toc-link" href="#8-按排名查找"><span class="trm-toc-text">8. 按排名查找</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="8.1 按排名查找的实现原理"><a rel="nofollow" class="trm-toc-link" href="#8-1-按排名查找的实现原理"><span class="trm-toc-text">8.1 按排名查找的实现原理</span></a></li><li class="trm-toc-item trm-toc-level-3" title="8.2 按排名查找的应用"><a rel="nofollow" class="trm-toc-link" href="#8-2-按排名查找的应用"><span class="trm-toc-text">8.2 按排名查找的应用</span></a></li><li class="trm-toc-item trm-toc-level-3" title="8.3 效率分析"><a rel="nofollow" class="trm-toc-link" href="#8-3-效率分析"><span class="trm-toc-text">8.3 效率分析</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="附（问题）"><a rel="nofollow" class="trm-toc-link" href="#附（问题）"><span class="trm-toc-text">附（问题）</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-3" title="9.1 什么场景下会需要用到跳表和红黑树？"><a rel="nofollow" class="trm-toc-link" href="#9-1-什么场景下会需要用到跳表和红黑树？"><span class="trm-toc-text">9.1 什么场景下会需要用到跳表和红黑树？</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-4" title="9.1.1 跳表适用场景"><a rel="nofollow" class="trm-toc-link" href="#9-1-1-跳表适用场景"><span class="trm-toc-text">9.1.1 跳表适用场景</span></a></li><li class="trm-toc-item trm-toc-level-4" title="9.1.2 红黑树适用场景"><a rel="nofollow" class="trm-toc-link" href="#9-1-2-红黑树适用场景"><span class="trm-toc-text">9.1.2 红黑树适用场景</span></a></li><li class="trm-toc-item trm-toc-level-4" title="9.1.3 Redis选择跳表而非红黑树的原因"><a rel="nofollow" class="trm-toc-link" href="#9-1-3-Redis选择跳表而非红黑树的原因"><span class="trm-toc-text">9.1.3 Redis选择跳表而非红黑树的原因</span></a></li></ol></li><li class="trm-toc-item trm-toc-level-3" title="9.2 普通链表的查找复杂度，为什么双向链表可以降低查询复杂度？"><a rel="nofollow" class="trm-toc-link" href="#9-2-普通链表的查找复杂度，为什么双向链表可以降低查询复杂度？"><span class="trm-toc-text">9.2 普通链表的查找复杂度，为什么双向链表可以降低查询复杂度？</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-4" title="9.2.1 普通链表的查找复杂度"><a rel="nofollow" class="trm-toc-link" href="#9-2-1-普通链表的查找复杂度"><span class="trm-toc-text">9.2.1 普通链表的查找复杂度</span></a></li><li class="trm-toc-item trm-toc-level-4" title="9.2.2 双向链表如何降低查询复杂度"><a rel="nofollow" class="trm-toc-link" href="#9-2-2-双向链表如何降低查询复杂度"><span class="trm-toc-text">9.2.2 双向链表如何降低查询复杂度</span></a></li><li class="trm-toc-item trm-toc-level-4" title="9.2.3 相关问题"><a rel="nofollow" class="trm-toc-link" href="#9-2-3-相关问题"><span class="trm-toc-text">9.2.3 相关问题</span></a><ol class="trm-toc-child"><li class="trm-toc-item trm-toc-level-5" title="1. 跳表与平衡树相比有什么优势和劣势？"><a rel="nofollow" class="trm-toc-link" href="#1-跳表与平衡树相比有什么优势和劣势？"><span class="trm-toc-text">1. 跳表与平衡树相比有什么优势和劣势？</span></a></li><li class="trm-toc-item trm-toc-level-5" title="2. 为什么Redis不使用B+树作为有序集合的实现？"><a rel="nofollow" class="trm-toc-link" href="#2-为什么Redis不使用B-树作为有序集合的实现？"><span class="trm-toc-text">2. 为什么Redis不使用B+树作为有序集合的实现？</span></a></li><li class="trm-toc-item trm-toc-level-5" title="3. 跳表的空间复杂度是多少？"><a rel="nofollow" class="trm-toc-link" href="#3-跳表的空间复杂度是多少？"><span class="trm-toc-text">3. 跳表的空间复杂度是多少？</span></a></li><li class="trm-toc-item trm-toc-level-5" title="4. 如何优化跳表以减少内存使用？"><a rel="nofollow" class="trm-toc-link" href="#4-如何优化跳表以减少内存使用？"><span class="trm-toc-text">4. 如何优化跳表以减少内存使用？</span></a></li><li class="trm-toc-item trm-toc-level-5" title="5. 跳表在并发环境下的表现如何？"><a rel="nofollow" class="trm-toc-link" href="#5-跳表在并发环境下的表现如何？"><span class="trm-toc-text">5. 跳表在并发环境下的表现如何？</span></a></li></ol></li></ol></li></ol></li><li class="trm-toc-item trm-toc-level-2" title="参考"><a rel="nofollow" class="trm-toc-link" href="#参考"><span class="trm-toc-text">参考</span></a></li></ol></li></ol>
      </div>
    </div>

            
<div class="trm-fixed-container">
    
        <div class="trm-fixed-btn post-toc-btn" data-title="目录">
            <i class="iconfont fas fa-th-list"></i>
        </div>
    
    
        <div class="trm-fixed-btn" data-title="阅读模式" onclick="asyncFun.switchReadMode()">
            <i class="iconfont fas fa-book-reader"></i>
        </div>
    
    
        <div class="trm-fixed-btn hidden-md" data-title="单栏和双栏切换" onclick="asyncFun.switchSingleColumn()">
            <i class="iconfont fas fa-arrows-alt-h"></i>
        </div>
    
    <div id="trm-back-top" class="trm-fixed-btn" data-title="回到顶部">
        <i class="iconfont fas fa-arrow-up"></i>
    </div>
</div>
        </div>
      </div>
      <!-- scroll container end -->
  </div>
  <!-- app wrapper end -->

  
  <!-- Plugin -->




    
    
<script src="https://unpkg.com/@fancyapps/ui@4.0/dist/fancybox.umd.js"></script>

    

    
        <script src="/js/plugins/typing.js?v=2.2.4"></script>
    

    

    <!-- 数学公式 -->
    

    <!-- 评论插件 -->
    
        

        
    

		




    <!-- Service Worker -->
    
    <!-- baidu push -->
    


<script id="async-script" src="/js/main.js?v=2.2.4"></script>

<!-- CDN -->


    

    

    



</body>

</html>