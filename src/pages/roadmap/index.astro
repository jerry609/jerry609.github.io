---
import PageLayout from '@/layouts/CommonPage.astro'
import RoadmapDrawer from '@/components/roadmap/RoadmapDrawer.astro'
import ActivityGraph from '@/components/roadmap/ActivityGraph.astro'

type Topic = {
  title: string
  prerequisites: { name: string; course: string }[]
  problems?: { id: string; title: string; score?: string; url?: string; vip?: boolean }[]
  rootSection?: {
    title: string
    desc?: string
    children?: any[]
    problems?: any[]
  }
}

const topics: Record<string, Topic> = {
  'sliding-window-two-pointers': {
    title: '滑动窗口与双指针',
    prerequisites: [],
    rootSection: {
      title: '滑动窗口与双指针',
      children: [
        {
          title: '一、定长滑动窗口',
          children: [
            {
              title: '§1.1 基础',
              desc: '【套路】教你解决定长滑窗！适用于所有定长滑窗题目！',
              problems: [
                { id: '1456', title: '定长子串中元音的最大数目', score: '1263' },
                { id: '643', title: '子数组最大平均数 I' },
                { id: '1343', title: '大小为 K 且平均值大于等于阈值的子数组数目', score: '1317' },
                { id: '2090', title: '半径为 k 的子数组平均值', score: '1358' },
                { id: '2379', title: '得到 K 个黑块的最少涂色次数', score: '1360' },
                { id: '2841', title: '几乎唯一子数组的最大和', score: '1546' },
                { id: '2461', title: '长度为 K 子数组中的最大和', score: '1553' },
                { id: '1423', title: '可获得的最大点数', score: '1574' },
                { id: '1176', title: '健身计划评估', vip: true },
                { id: '1100', title: '长度为 K 的无重复字符子串', vip: true },
                { id: '1852', title: '每个子数组的数字种类数', vip: true },
                { id: '1151', title: '最少交换次数来组合所有的 1', vip: true },
                { id: '2107', title: '分享 K 个糖果后独特口味的数量', vip: true }
              ]
            },
            {
              title: '§1.2 进阶（选做）',
              problems: [
                { id: '3679', title: '使库存平衡的最少丢弃次数', score: '1639' },
                { id: '1052', title: '爱生气的书店老板' },
                { id: '3439', title: '重新安排会议得到最多空余时间 I', score: '1729' },
                { id: '3694', title: '删除子字符串后不同的终点', score: '1739' },
                { id: '3652', title: '按策略买卖股票的最佳时机' },
                { id: '2134', title: '最少交换次数来组合所有的 1 II', score: '1748' },
                { id: '1652', title: '拆炸弹', desc: '做到 O(n)' },
                { id: '1297', title: '子串的最大出现次数', score: '1748' },
                { id: '2653', title: '滑动子数组的美丽值', score: '1786' },
                { id: '1888', title: '使二进制字符串字符交替的最少反转次数', score: '2006' },
                { id: '567', title: '字符串的排列' },
                { id: '438', title: '找到字符串中所有字母异位词' },
                { id: '30', title: '串联所有单词的子串' },
                { id: '2156', title: '查找给定哈希值的子串', score: '2063' },
                { id: '2953', title: '统计完全子字符串', score: '2449' },
                { id: '1016', title: '子串能表示从 1 到 N 数字的二进制串', desc: '做到 O(|s|)' },
                { id: '3672', title: '子数组中加权众数的总和', vip: true },
                { id: '683', title: 'K 个关闭的灯泡', vip: true, desc: '做到 O(n)' },
                { id: '2067', title: '等计数子串的数量', vip: true },
                { id: '2524', title: '子数组的最大频率分数', vip: true }
              ]
            },
            {
              title: '§1.3 其他（选做）',
              problems: [
                { id: '2200', title: '找出数组中的所有 K 近邻下标', score: '1266', desc: '做法不止一种' },
                { id: '2269', title: '找到一个数字的 K 美丽值', score: '1280' },
                { id: '1984', title: '学生分数的最小差值', score: '1306' },
                { id: '1461', title: '检查一个字符串是否包含所有长度为 K 的二进制子串', score: '1504' },
                { id: '220', title: '存在重复元素 III' }
              ]
            }
          ]
        },
        {
          title: '二、不定长滑动窗口',
          desc: '不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，求子数组个数。\n\n注：滑动窗口相当于在维护一个队列。右指针的移动可以视作入队，左指针的移动可以视作出队。',
          children: [
            {
              title: '§2.1 越短越合法/求最长/最大',
              children: [
                {
                  title: '§2.1.1 基础',
                  problems: [
                    { id: '3', title: '无重复字符的最长子串' },
                    { id: '3090', title: '每个字符最多出现两次的最长子字符串', score: '1329' },
                    { id: '1493', title: '删掉一个元素以后全为 1 的最长子数组', score: '1423' },
                    { id: '3634', title: '使数组平衡的最少移除数目', score: '1453' },
                    { id: '1208', title: '尽可能使字符串相等', score: '1497' },
                    { id: '904', title: '水果成篮', score: '1516' },
                    { id: '1695', title: '删除子数组的最大得分', score: '1529' },
                    { id: '2958', title: '最多 K 个重复元素的最长子数组', score: '1535' },
                    { id: '2024', title: '考试的最大困扰度', score: '1643' },
                    { id: '1004', title: '最大连续 1 的个数 III', score: '1656' },
                    { id: '1658', title: '将 x 减到 0 的最小操作数', score: '1817' },
                    { id: '3641', title: '最长半重复子数组', vip: true }
                  ]
                },
                {
                  title: '§2.1.2 进阶（选做）',
                  problems: [
                    { id: '2730', title: '找到最长的半重复子字符串', desc: '非暴力做法' },
                    { id: '2779', title: '数组的最大美丽值', score: '1638' },
                    { id: '1838', title: '最高频元素的频数', score: '1876' },
                    { id: '2516', title: '每种字符至少取 K 个', score: '1948' },
                    { id: '2831', title: '找出最长等值子数组', score: '1976' },
                    { id: '2271', title: '毯子覆盖的最多白色砖块数', score: '2022' },
                    { id: '2106', title: '摘水果', score: '2062' },
                    { id: '2555', title: '两个线段获得的最多奖品', score: '2081' },
                    { id: '2009', title: '使数组连续的最少操作数', score: '2084' },
                    { id: '1610', title: '可见点的最大数目', score: '2147' },
                    { id: '2781', title: '最长合法子字符串的长度', score: '2204' },
                    { id: '3411', title: '最长乘积等价子数组', score: '2300', desc: '非暴力做法' },
                    { id: '3413', title: '收集连续 K 个袋子可以获得的最多硬币数量', score: '2374' },
                    { id: '395', title: '至少有 K 个重复字符的最长子串' },
                    { id: '1763', title: '最长的美好子字符串', desc: '非暴力做法' },
                    { id: '2968', title: '执行操作使频率分数最大', score: '2444' },
                    { id: '1040', title: '移动石子直到连续 II', score: '2456' },
                    { id: '487', title: '最大连续 1 的个数 II', vip: true },
                    { id: '159', title: '至多包含两个不同字符的最长子串', vip: true },
                    { id: '340', title: '至多包含 K 个不同字符的最长子串', vip: true }
                  ]
                }
              ]
            },
            {
              title: '§2.2 越长越合法/求最短/最小',
              problems: [
                { id: '209', title: '长度最小的子数组' },
                { id: '2904', title: '最短且字典序最小的美丽子字符串', desc: '做到 O(n^2)' },
                { id: '1234', title: '替换子串得到平衡字符串', score: '1878' },
                { id: '2875', title: '无限数组的最短子数组', score: '1914' },
                { id: '76', title: '最小覆盖子串' },
                { id: '632', title: '最小区间', desc: '做法不止一种' }
              ]
            },
            {
              title: '§2.3 求子数组个数',
              children: [
                {
                  title: '§2.3.1 越短越合法',
                  desc: '一般要写 ans += right - left + 1。\n\n内层循环结束后，[left,right] 这个子数组是满足题目要求的。由于子数组越短，越能满足题目要求，所以除了 [left,right]，还有 [left+1,right],[left+2,right],…,[right,right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 left,left+1,left+2,…,right 的所有子数组都是满足要求的，这一共有 right−left+1 个。',
                  problems: [
                    { id: '713', title: '乘积小于 K 的子数组' },
                    { id: '3258', title: '统计满足 K 约束的子字符串数量 I', desc: '做到 O(n)' },
                    { id: '2302', title: '统计得分小于 K 的子数组数目', score: '1808' },
                    { id: '2762', title: '不间断子数组', score: '1940' },
                    { id: 'LCP 68', title: '美观的花束' },
                    { id: '2743', title: '计算没有重复字符的子字符串数量', vip: true },
                    { id: '3134', title: '找出唯一性数组的中位数', score: '2451' },
                    { id: '3261', title: '统计满足 K 约束的子字符串数量 II', score: '2659', desc: '子串的子串' }
                  ]
                },
                {
                  title: '§2.3.2 越长越合法',
                  desc: '一般要写 ans += left。\n\n内层循环结束后，[left,right] 这个子数组是不满足题目要求的，但在退出循环之前的最后一轮循环，[left−1,right] 是满足题目要求的。由于子数组越长，越能满足题目要求，所以除了 [left−1,right]，还有 [left−2,right],[left−3,right],…,[0,right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 0,1,2,…,left−1 的所有子数组都是满足要求的，这一共有 left 个。\n\n我们关注的是 left−1 的合法性，而不是 left。',
                  problems: [
                    { id: '1358', title: '包含所有三种字符的子字符串数目', score: '1646' },
                    { id: '2962', title: '统计最大元素出现至少 K 次的子数组', score: '1701' },
                    { id: '3325', title: '字符至少出现 K 次的子字符串 I', desc: '做到 O(n)' },
                    { id: '2799', title: '统计完全子数组的数目', desc: '做到 O(n)' },
                    { id: '2537', title: '统计好子数组的数目', score: '1892' },
                    { id: '3298', title: '统计重新排列后包含另一个字符串的子字符串数目 II', score: '1909', desc: '同 76 题' },
                    { id: '2495', title: '乘积为偶数的子数组数', vip: true }
                  ]
                },
                {
                  title: '§2.3.3 恰好型滑动窗口',
                  desc: '例如，要计算有多少个元素和恰好等于 k 的子数组，可以把问题变成：\n\n计算有多少个元素和 ≥k 的子数组。\n计算有多少个元素和 >k，也就是 ≥k+1 的子数组。\n答案就是元素和 ≥k 的子数组个数，减去元素和 ≥k+1 的子数组个数。这里把 > 转换成 ≥，从而可以把滑窗逻辑封装成一个函数 solve，然后用 solve(k)−solve(k+1) 计算，无需编写两份滑窗代码。\n\n总结：「恰好」可以拆分成两个「至少」，也就是两个「越长越合法」的滑窗问题。\n\n注：也可以把问题变成 ≤k 减去 ≤k−1，即两个「至多」。可根据题目选择合适的变形方式。\n\n注：也可以把两个滑动窗口合并起来，维护同一个右端点 right 和两个左端点 left1 和 left2 ，我把这种写法叫做三指针滑动窗口。',
                  problems: [
                    { id: '930', title: '和相同的二元子数组', score: '1592' },
                    { id: '1248', title: '统计「优美子数组」', score: '1624' },
                    { id: '3306', title: '元音辅音字符串计数 II', score: '2200' },
                    { id: '992', title: 'K 个不同整数的子数组', score: '2210' }
                  ]
                }
              ]
            },
            {
              title: '§2.4 其他（选做）',
              problems: [
                { id: '825', title: '适龄的朋友', score: '1697' },
                { id: '2401', title: '最长优雅子数组', score: '1750' },
                { id: '1156', title: '单字符重复子串的最大长度', score: '1787', desc: '有简单做法' },
                { id: '424', title: '替换后的最长重复字符' },
                { id: '438', title: '找到字符串中所有字母异位词', desc: '有定长滑窗/不定长滑窗两种写法' },
                { id: '1712', title: '将数组分成三个子数组的方案数', score: '2079' },
                { id: 'LCR 180', title: '文件组合' },
                { id: '1918', title: '第 K 小的子数组和', vip: true }
              ]
            }
          ]
        }
      ]
    }
  },
  'binary-search': {
    title: '二分算法',
    prerequisites: [],
    rootSection: {
      title: '二分算法',
      children: [
        {
          title: '一、二分查找',
          desc: '讲解：二分查找 红蓝染色法【基础算法精讲 04】\n\n设 nums 为递增（非递减）数组，长为 n。\n\n需求\t写法\t如果不存在\n≥x 的第一个元素的下标\tlowerBound(nums,x)\t结果为 n\n>x 的第一个元素的下标\tlowerBound(nums,x+1)\t结果为 n\n<x 的最后一个元素的下标\tlowerBound(nums,x)−1\t结果为 −1\n≤x 的最后一个元素的下标\tlowerBound(nums,x+1)−1\t结果为 −1\n需求\t写法\n<x 的元素个数\tlowerBound(nums,x)\n≤x 的元素个数\tlowerBound(nums,x+1)\n≥x 的元素个数\tn−lowerBound(nums,x)\n>x 的元素个数\tn−lowerBound(nums,x+1)\n注意 <x 和 ≥x 互为补集，二者之和为 n。≤x 和 >x 同理。',
          children: [
            {
              title: '§1.1 基础',
              problems: [
                { id: '34', title: '在排序数组中查找元素的第一个和最后一个位置', desc: '推荐阅读我题解中的答疑' },
                { id: '35', title: '搜索插入位置', desc: '推荐阅读我题解中的答疑' },
                { id: '704', title: '二分查找' },
                { id: '744', title: '寻找比目标字母大的最小字母' },
                { id: '2529', title: '正整数和负整数的最大计数', desc: '做到 O(logn)' }
              ]
            },
            {
              title: '§1.2 进阶',
              desc: '部分题目需要先排序，然后在有序数组上二分查找。',
              problems: [
                { id: '2300', title: '咒语和药水的成功对数', score: '1477' },
                { id: '1385', title: '两个数组间的距离值' },
                { id: '2389', title: '和有限的最长子序列' },
                { id: '1170', title: '比较字符串最小字母出现频次' },
                { id: '2080', title: '区间内查询数字的频率', score: '1702' },
                { id: '3488', title: '距离最小相等元素查询', desc: '做法不止一种' },
                { id: '2563', title: '统计公平数对的数目', score: '1721' },
                { id: '2070', title: '每一个查询的最大美丽值', score: '1724' },
                { id: '1146', title: '快照数组', score: '1771' },
                { id: '981', title: '基于时间的键值存储', desc: '同 1146 题' },
                { id: '3508', title: '设计路由器', score: '1851' },
                { id: '658', title: '找到 K 个最接近的元素' },
                { id: '1818', title: '绝对差值和', score: '1934' },
                { id: '911', title: '在线选举', score: '2001' },
                { id: 'LCP 08', title: '剧情触发时间' },
                { id: '1182', title: '与目标颜色间的最短距离', vip: true },
                { id: '2819', title: '购买巧克力后的最小相对损失', vip: true },
                { id: '1287', title: '有序数组中出现次数超过 25% 的元素', desc: '做到 O(logn)' },
                { id: '2476', title: '二叉搜索树最近节点查询', score: '1597' },
                { id: '1150', title: '检查一个数是否在数组中占绝大多数', vip: true }
              ]
            }
          ]
        },
        {
          title: '二、二分答案',
          desc: '“花费一个 log 的时间，增加了一个条件。” —— 二分答案',
          children: [
            {
              title: '§2.1 求最小',
              desc: '题目求什么，就二分什么。\n\n答疑\n问：如何把二分答案与数组上的二分查找联系起来？\n答：假设答案在区间 [2,5] 中，我们相当于在一个虚拟数组 [check(2),check(3),check(4),check(5)] 中二分找第一个（或者最后一个）值为 true 的 check(x)。这同样可以用红蓝染色法思考。\n\n问：有些题目，明明 m 可以是答案，但却不在初始二分区间中。比如闭区间二分初始化 right=m−1（或者开区间 right=m），这不会算错吗？\n答：不会算错。注意「答案所在区间」和「二分区间」是两个概念。想一想，如果二分的 while 循环每次更新的都是 left，那么最终答案是什么？正好就是 m。一般地，如果一开始就能确定 m 一定可以满足题目要求，那么 m 是不需要在二分区间中的。换句话说，二分区间是「尚未确定是否满足题目要求」的数的范围。那些在区间外面的数，都是已确定的满足（不满足）题目要求的数。\n\n问：什么是循环不变量？\n答：想一想，对于求最小的题目，开区间二分的写法，为什么最终返回的是 right，而不是别的数？在初始化（循环之前）、循环中、循环结束后，都时时刻刻保证 check(right) == true 和 check(left) == false，这就叫循环不变量。根据循环不变量，循环结束时 left+1=right，那么 right 就是最小的满足要求的数（因为再 −1 就不满足要求了），所以答案是 right。\n\n注：部分题目可以优化二分边界，减少二分次数，从而减少代码运行时间。对于初次接触二分答案的同学，无需强求自己写出最优的代码，设定一个比较大的二分上界也是可以的。\n\n开区间二分模板（求最小）：\n```python\nclass Solution:\n    # 计算满足 check(x) == True 的最小整数 x\n    def binarySearchMin(self, nums: List[int]) -> int:\n        # 二分猜答案：判断 mid 是否满足题目要求\n        def check(mid: int) -> bool:\n            # TODO\n\n        left =   # 循环不变量：check(left) 恒为 False\n        right =   # 循环不变量：check(right) 恒为 True\n        while left + 1 < right:  # 开区间不为空\n            mid = (left + right) // 2\n            if check(mid):  # 说明 check(>= mid 的数) 均为 True\n                right = mid  # 接下来在 (left, mid) 中二分答案\n            else:  # 说明 check(<= mid 的数) 均为 False\n                left = mid  # 接下来在 (mid, right) 中二分答案\n        # 循环结束后 left+1 = right\n        # 此时 check(left) == False 而 check(left+1) == check(right) == True\n        # 所以 right 就是最小的满足 check 的值\n        return right\n```',
              problems: [
                { id: '1283', title: '使结果不超过阈值的最小除数', score: '1542' },
                { id: '2187', title: '完成旅途的最少时间', score: '1641' },
                { id: '1011', title: '在 D 天内送达包裹的能力', score: '1725' },
                { id: '875', title: '爱吃香蕉的珂珂', score: '1766' },
                { id: '3296', title: '移山所需的最少秒数', desc: '注：由于有其他做法，难度分会低一些，二分做法估计 1850' },
                { id: '3639', title: '变为活跃状态的最小时间', score: '1853' },
                { id: '475', title: '供暖器' },
                { id: '2594', title: '修车的最少时间', score: '1915' },
                { id: '1482', title: '制作 m 束花所需的最少天数', score: '1946' },
                { id: '3048', title: '标记所有下标的最早秒数 I', score: '2263' },
                { id: '2604', title: '吃掉所有谷子的最短时间', vip: true },
                { id: '2702', title: '使数字变为非正数的最小操作次数', vip: true },
                { id: '1870', title: '准时到达的列车最小时速', score: '1676', desc: '避免浮点数' },
                { id: '3453', title: '分割正方形 I', score: '1735', desc: '浮点二分（也可以避免浮点数）' }
              ]
            },
            {
              title: '§2.2 求最大',
              desc: '一图掌握二分答案！四种写法！\n\n在练习时，请注意「求最小」和「求最大」的二分写法上的区别。\n\n前面的「求最小」和二分查找求「排序数组中某元素的第一个位置」是类似的，按照红蓝染色法，左边是不满足要求的（红色），右边则是满足要求的（蓝色）。\n\n「求最大」的题目则相反，左边是满足要求的（蓝色），右边是不满足要求的（红色）。这会导致二分写法和上面的「求最小」有一些区别。\n\n以开区间二分为例：\n\n求最小：check(mid) == true 时更新 right = mid，反之更新 left = mid，最后返回 right。\n求最大：check(mid) == true 时更新 left = mid，反之更新 right = mid，最后返回 left。\n对于开区间写法，简单来说 check(mid) == true 时更新的是谁，最后就返回谁。相比其他二分写法，开区间写法不需要思考加一减一等细节，推荐使用开区间写二分。\n\n开区间二分模板（求最大）：\n```python\nclass Solution:\n    # 计算满足 check(x) == True 的最大整数 x\n    def binarySearchMax(self, nums: List[int]) -> int:\n        # 二分猜答案：判断 mid 是否满足题目要求\n        def check(mid: int) -> bool:\n            # TODO\n\n        left =   # 循环不变量：check(left) 恒为 True\n        right =   # 循环不变量：check(right) 恒为 False\n        while left + 1 < right:\n            mid = (left + right) // 2\n            if check(mid):\n                left = mid  # 注意这里更新的是 left，和上面的模板反过来\n            else:\n                right = mid\n        # 循环结束后 left+1 = right\n        # 此时 check(left) == True 而 check(left+1) == check(right) == False\n        # 所以 left 就是最大的满足 check 的值\n        return left  # check 更新的是谁，最终就返回谁\n```',
              problems: [
                { id: '275', title: 'H 指数 II' },
                { id: '2226', title: '每个小孩最多能分到多少糖果', score: '1646' },
                { id: '2982', title: '找出出现至少三次的最长特殊子字符串 II', score: '1773' },
                { id: '2576', title: '求出最多标记下标', score: '1843' },
                { id: '1898', title: '可移除字符的最大数目', score: '1913' },
                { id: '1802', title: '有界数组中指定下标处的最大值', score: '1929' },
                { id: '1642', title: '可以到达的最远建筑', score: '1962' },
                { id: '2861', title: '最大合金数', score: '1981' },
                { id: '3007', title: '价值和小于等于 K 的最大数字', score: '2258' },
                { id: '2141', title: '同时运行 N 台电脑的最长时间', score: '2265' },
                { id: '2258', title: '逃离火灾', score: '2347' },
                { id: '2071', title: '你可以安排的最多任务数目', score: '2648' },
                { id: 'LCP 78', title: '城墙防线' },
                { id: '1618', title: '找出适应屏幕的最大字号', vip: true },
                { id: '1891', title: '割绳子', vip: true },
                { id: '2137', title: '通过倒水操作让所有的水桶所含水量相等', vip: true },
                { id: '3344', title: '最大尺寸数组', vip: true },
                { id: '644', title: '子数组最大平均数 II', vip: true }
              ]
            },
            {
              title: '§2.3 二分间接值',
              desc: '二分的不是答案，而是一个和答案有关的值（间接值）。',
              problems: [
                { id: '3143', title: '正方形中的最多点数', score: '1697' },
                { id: '1648', title: '销售价值减少的颜色球', score: '2050' }
              ]
            },
            {
              title: '§2.4 最小化最大值',
              desc: '本质是二分答案求最小。二分的 mid 表示上界。\n\n好比用一个盖子（上界）去压住最大值，看看能否压住（check 函数）。',
              problems: [
                { id: '410', title: '分割数组的最大值' },
                { id: '2064', title: '分配给商店的最多商品的最小值', score: '1886' },
                { id: '3613', title: '最小化连通分量的最大成本', desc: '约 1900' },
                { id: '1760', title: '袋子里最少数目的球', score: '1940' },
                { id: '1631', title: '最小体力消耗路径', score: '1948' },
                { id: '2439', title: '最小化数组中的最大值', score: '1965' },
                { id: '2560', title: '打家劫舍 IV', score: '2081' },
                { id: '778', title: '水位上升的泳池中游泳', score: '2097', desc: '相当于最小化路径最大值' },
                { id: '2616', title: '最小化数对的最大差值', score: '2155' },
                { id: '3419', title: '图的最大边权的最小值', score: '2243' },
                { id: '2513', title: '最小化两个数组中的最大值', score: '2302' },
                { id: '3733', title: '完成所有送货任务的最少时间', desc: '同 2513 题' },
                { id: '3399', title: '字符相同的最短子字符串 II', score: '2376' },
                { id: '3605', title: '数组的最小稳定性因子', score: '2410' },
                { id: 'LCP 12', title: '小张刷题计划' },
                { id: '774', title: '最小化去加油站的最大距离', vip: true }
              ]
            },
            {
              title: '§2.5 最大化最小值',
              desc: '本质是二分答案求最大。二分的 mid 表示下界。',
              problems: [
                { id: '3281', title: '范围内整数的最大得分', score: '1768' },
                { id: '3620', title: '恢复网络路径', score: '1998' },
                { id: '2517', title: '礼盒的最大甜蜜度', score: '2021' },
                { id: '1552', title: '两球之间的磁力', desc: '同 2517 题' },
                { id: '3710', title: '最大划分因子', score: '2135' },
                { id: '2812', title: '找出最安全路径', score: '2154' },
                { id: '2528', title: '最大化城市的最小电量', score: '2236' },
                { id: '3600', title: '升级后最大生成树稳定性', score: '2301', desc: '做法不止一种' },
                { id: '3449', title: '最大化游戏分数的最小值', score: '2748' },
                { id: '3464', title: '正方形上的点之间的最大距离', score: '2806' },
                { id: '1102', title: '得分最高的路径', vip: true },
                { id: '1231', title: '分享巧克力', vip: true }
              ]
            },
            {
              title: '§2.6 第 K 小/大',
              desc: '例如数组 [1,1,1,2,2]，其中第 1 小、第 2 小和第 3 小的数都是 1，第 4 小和第 5 小的数都是 2。\n\n第 k 小等价于：求最小的 x，满足 ≤x 的数至少有 k 个。\n第 k 大等价于：求最大的 x，满足 ≥x 的数至少有 k 个。\n注 1：一般规定 k 从 1 开始，而不是像数组下标那样从 0 开始。\n\n注 2：部分题目也可以用堆解决。',
              problems: [
                { id: '668', title: '乘法表中第 K 小的数' },
                { id: '378', title: '有序矩阵中第 K 小的元素' },
                { id: '719', title: '找出第 K 小的数对距离' },
                { id: '878', title: '第 N 个神奇数字', score: '1897' },
                { id: '1201', title: '丑数 III', score: '2039' },
                { id: '793', title: '阶乘函数后 K 个零', score: '2100' },
                { id: '373', title: '查找和最小的 K 对数字' },
                { id: '1439', title: '有序矩阵中的第 k 个最小数组和', score: '2134' },
                { id: '786', title: '第 K 个最小的质数分数', score: '2169' },
                { id: '3116', title: '单面值组合的第 K 小金额', score: '2387' },
                { id: '3134', title: '找出唯一性数组的中位数', score: '2451' },
                { id: '2040', title: '两个有序数组的第 K 小乘积', score: '2518' },
                { id: '2386', title: '找出数组的第 K 大和', score: '2648', desc: '转化' },
                { id: '1508', title: '子数组和排序后的区间和' },
                { id: '3691', title: '最大子数组总值 II', desc: '做到时间复杂度与 k 无关' },
                { id: '3520', title: '逆序对计数的最小阈值', vip: true },
                { id: '1918', title: '第 K 小的子数组和', vip: true }
              ]
            }
          ]
        },
        {
          title: '三、三分法',
          problems: [
            { id: '1515', title: '服务中心的最佳位置', score: '2157', desc: '做法不止一种' }
          ]
        },
        {
          title: '四、其他',
          problems: [
            { id: '69', title: 'x 的平方根', desc: '二分求最大的 m，满足 m^2 ≤x（也可以二分求最小的满足 m^2 >x 的 m，减一得到答案）' },
            { id: '74', title: '搜索二维矩阵' },
            { id: '278', title: '第一个错误的版本' },
            { id: '374', title: '猜数字大小' },
            { id: '162', title: '寻找峰值' },
            { id: '1901', title: '寻找峰值 II' },
            { id: '852', title: '山脉数组的峰顶索引' },
            { id: '1095', title: '山脉数组中查找目标值', score: '1827' },
            { id: '153', title: '寻找旋转排序数组中的最小值' },
            { id: '154', title: '寻找旋转排序数组中的最小值 II' },
            { id: '33', title: '搜索旋转排序数组' },
            { id: '81', title: '搜索旋转排序数组 II' },
            { id: '222', title: '完全二叉树的节点个数' },
            { id: '1539', title: '第 k 个缺失的正整数' },
            { id: '540', title: '有序数组中的单一元素' },
            { id: '4', title: '寻找两个正序数组的中位数' },
            { id: '1064', title: '不动点', vip: true },
            { id: '702', title: '搜索长度未知的有序数组', vip: true },
            { id: '2936', title: '包含相等值数字块的数量', vip: true },
            { id: '1060', title: '有序数组中的缺失元素', vip: true },
            { id: '1198', title: '找出所有行中最小公共元素', vip: true },
            { id: '1428', title: '至少有一个 1 的最左端列', vip: true },
            { id: '1533', title: '找到最大整数的索引', vip: true },
            { id: '2387', title: '行排序矩阵的中位数', vip: true },
            { id: '302', title: '包含全部黑色像素的最小矩形', vip: true }
          ]
        }
      ]
    }
  },
  'monotonic-stack': {
    title: '单调栈',
    prerequisites: [],
    problems: []
  },
  'grid-graph': {
    title: '网格图',
    prerequisites: [],
    problems: []
  },
  'bit-manipulation': {
    title: '位运算',
    prerequisites: [],
    problems: []
  },
  'graph-algorithms': {
    title: '图论算法',
    prerequisites: [],
    problems: []
  },
  'dynamic-programming': {
    title: '动态规划',
    prerequisites: [],
    problems: []
  },
  'data-structures': {
    title: '常用数据结构',
    prerequisites: [],
    problems: []
  },
  'math': {
    title: '数学算法',
    prerequisites: [],
    problems: []
  },
  'greedy-thinking': {
    title: '贪心与思维',
    prerequisites: [],
    problems: []
  },
  'linked-list-tree-backtracking': {
    title: '链表、二叉树与回溯',
    prerequisites: [],
    problems: []
  },
  'strings': {
    title: '字符串',
    prerequisites: [],
    problems: []
  }
}

const nodes = [
  { id: 'sliding-window-two-pointers', x: 400, y: 50 },
  { id: 'binary-search', x: 150, y: 200 },
  { id: 'linked-list-tree-backtracking', x: 650, y: 200 },
  { id: 'monotonic-stack', x: 150, y: 350 },
  { id: 'data-structures', x: 400, y: 350 },
  { id: 'strings', x: 650, y: 350 },
  { id: 'grid-graph', x: 150, y: 500 },
  { id: 'graph-algorithms', x: 400, y: 500 },
  { id: 'greedy-thinking', x: 650, y: 500 },
  { id: 'math', x: 150, y: 650 },
  { id: 'bit-manipulation', x: 400, y: 650 },
  { id: 'dynamic-programming', x: 400, y: 800 }
]

function countProblemsInSection(section: any): number {
  let count = 0
  if (section.problems) count += section.problems.length
  if (section.children) {
    section.children.forEach((child: any) => (count += countProblemsInSection(child)))
  }
  return count
}

function countProblems(topic: Topic): number {
  if (topic.problems) return topic.problems.length
  if (topic.rootSection) return countProblemsInSection(topic.rootSection)
  return 0
}

const edges = [
  ['sliding-window-two-pointers', 'binary-search'],
  ['sliding-window-two-pointers', 'linked-list-tree-backtracking'],
  ['binary-search', 'monotonic-stack'],
  ['linked-list-tree-backtracking', 'data-structures'],
  ['linked-list-tree-backtracking', 'strings'],
  ['monotonic-stack', 'grid-graph'],
  ['data-structures', 'graph-algorithms'],
  ['strings', 'greedy-thinking'],
  ['grid-graph', 'graph-algorithms'],
  ['graph-algorithms', 'math'],
  ['graph-algorithms', 'bit-manipulation'],
  ['math', 'dynamic-programming'],
  ['bit-manipulation', 'dynamic-programming'],
  ['greedy-thinking', 'dynamic-programming']
]

const headings = [{ depth: 2, slug: 'roadmap', text: 'Algorithm Roadmap' }]
---

<PageLayout title='Algorithm Roadmap' {headings}>
  <p class='mb-6 text-muted-foreground'>
    点击节点查看题目列表，参考
    <a href='https://leetcode.cn/discuss/post/RvFUtj/' target='_blank' class='text-primary hover:underline'>灵茶山艾府 - 如何科学刷题？</a>。
  </p>

  <div class='roadmap-container'>
    <!-- Mini-map and controls -->
    <div class='roadmap-controls'>
      <div class='mini-map'>
        <svg class='mini-map-svg' viewBox='0 0 1000 1200' xmlns='http://www.w3.org/2000/svg'>
          {edges.map(([from, to]) => {
            const a = nodes.find(n => n.id === from)
            const b = nodes.find(n => n.id === to)
            if (!a || !b) return null
            const rectW = 180, rectH = 64
            const x1 = a.x + rectW / 2, y1 = a.y + rectH / 2
            const x2 = b.x + rectW / 2, y2 = b.y
            return <line x1={x1} y1={y1} x2={x2} y2={y2} stroke='#475569' stroke-width='6' />
          })}
          {nodes.map(n => (
            <rect x={n.x} y={n.y} width='180' height='64' rx='8' fill='#334155' stroke='#60a5fa' stroke-width='4' />
          ))}
          <rect id='mini-viewport' class='mini-viewport' x='0' y='0' width='1000' height='900' fill='rgba(96, 165, 250, 0.15)' stroke='#60a5fa' stroke-width='8' />
        </svg>
      </div>
      <button id='reset-btn' class='reset-btn' title='Reset View'>
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
        <span>Reset</span>
      </button>
      <div class='zoom-info' id='zoom-info'>100%</div>
      <div class='zoom-btns'>
        <button id='zoom-in' class='zoom-btn' title='Zoom In'>+</button>
        <button id='zoom-out' class='zoom-btn' title='Zoom Out'>-</button>
      </div>
    </div>

    <div class='roadmap-box'>
      <svg class='roadmap-svg' viewBox='0 0 1000 1200' xmlns='http://www.w3.org/2000/svg'>
        <g id='canvas' transform='translate(0,0) scale(1)'>
        {edges.map(([from, to]) => {
          const a = nodes.find(n => n.id === from)
          const b = nodes.find(n => n.id === to)
          if (!a || !b) return null
          const rectW = 180, rectH = 64
          const x1 = a.x + rectW / 2, y1 = a.y + rectH / 2
          const x2 = b.x + rectW / 2, y2 = b.y
          const cy = (y1 + y2) / 2
          return <path d={`M${x1} ${y1} C${x1} ${cy}, ${x2} ${cy}, ${x2} ${y2}`} class='edge-line' />
        })}
        {nodes.map(n => (
          <g class='node-box' data-id={n.id} transform={`translate(${n.x},${n.y})`}>
            <rect width='180' height='64' rx='12' />
            <rect class='node-progress' x='0' y='60' width='0' height='4' rx='2' />
            <text x='90' y='38'>{topics[n.id].title}</text>
          </g>
        ))}
      </g>
    </svg>
  </div>
</div>

  <RoadmapDrawer topics={topics} />

  <!-- Activity Graph -->
  <div class='mt-12 mb-8'>
    <h2 class='text-2xl font-bold mb-4'>Activity</h2>
    <div class='border rounded-xl p-4 bg-card'>
      <ActivityGraph />
    </div>
  </div>

  <!-- List View Section -->
  <div class='mt-12'>
    <h2 class='text-2xl font-bold mb-6'>All Topics</h2>
    <div class='grid gap-6 sm:grid-cols-2 lg:grid-cols-3'>
      {Object.entries(topics).map(([id, topic]) => (
        <div class='topic-card border rounded-xl p-4 bg-card hover:shadow-md transition-shadow' data-id={id}>
          <h3 class='text-lg font-semibold mb-2'>{topic.title}</h3>
          <div class='text-sm text-muted-foreground mb-3'>
            {countProblems(topic)} Problems
          </div>
          <div class='bar-track h-2 mb-3 bg-muted rounded-full overflow-hidden'><div class='bar-fill list-progress-bar h-full bg-primary transition-all duration-500' data-id={id} style='width: 0%'></div></div>
          <button class='text-primary text-sm font-medium hover:underline open-topic-btn' data-id={id}>
            View Problems →
          </button>
        </div>
      ))}
    </div>
  </div>
</PageLayout>

<script define:vars={{ topics }} is:inline>
  document.addEventListener('DOMContentLoaded', () => {
    // Open Drawer Helper
    function open(id) {
      if (window.openRoadmapDrawer) {
        window.openRoadmapDrawer(id)
      }
    }

    document.querySelectorAll('.node-box').forEach(el => {
      el.addEventListener('click', (evt) => {
        evt.stopPropagation()
        open(el.dataset.id)
      })
    })

    document.querySelectorAll('.open-topic-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        open(btn.dataset.id)
      })
    })

    // Panning / Dragging the canvas
    const svg = document.querySelector('.roadmap-svg')
    const canvas = document.getElementById('canvas')
    const miniViewport = document.getElementById('mini-viewport')
    const resetBtn = document.getElementById('reset-btn')
    const zoomInfo = document.getElementById('zoom-info')
    const zoomInBtn = document.getElementById('zoom-in')
    const zoomOutBtn = document.getElementById('zoom-out')
    
    let isPanning = false
    let startX = 0, startY = 0
    let panX = 0, panY = 0
    let scale = 1
    const minScale = 0.3, maxScale = 2.5

    function updateTransform() {
      canvas.setAttribute('transform', `translate(${panX},${panY}) scale(${scale})`)
      zoomInfo.textContent = `${Math.round(scale * 100)}%`
      updateMiniMap()
    }

    function zoom(delta) {
      scale = Math.min(maxScale, Math.max(minScale, scale * delta))
      
      // Zoom towards center of viewport
      const rect = svg.getBoundingClientRect()
      const centerX = rect.width / 2
      const centerY = rect.height / 2
      
      // Adjust pan to keep center fixed
      panX = centerX - (centerX - panX) * (scale / oldScale)
      panY = centerY - (centerY - panY) * (scale / oldScale)
      
      updateTransform()
    }

    zoomInBtn.addEventListener('click', () => zoom(1.2))
    zoomOutBtn.addEventListener('click', () => zoom(0.8))

    function updateMiniMap() {
      if (!miniViewport) return
      // viewport in SVG coordinates
      const vw = 1000 / scale
      const vh = 1200 / scale
      const vx = -panX / scale
      const vy = -panY / scale
      miniViewport.setAttribute('x', vx)
      miniViewport.setAttribute('y', vy)
      miniViewport.setAttribute('width', vw)
      miniViewport.setAttribute('height', vh)
    }

    function resetView() {
      panX = 0
      panY = 0
      scale = 1
      updateTransform()
    }

    resetBtn.addEventListener('click', resetView)

    svg.style.cursor = 'grab'

    svg.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return
      // prevent panning when clicking node (nodes stopPropagation above)
      isPanning = true
      startX = e.clientX
      startY = e.clientY
      svg.style.cursor = 'grabbing'
    })

    document.addEventListener('mousemove', (e) => {
      if (!isPanning) return
      const dx = e.clientX - startX
      const dy = e.clientY - startY
      canvas.setAttribute('transform', `translate(${panX + dx},${panY + dy}) scale(${scale})`)
      updateMiniMap()
    })

    document.addEventListener('mouseup', (e) => {
      if (!isPanning) return
      const dx = e.clientX - startX
      const dy = e.clientY - startY
      panX += dx
      panY += dy
      isPanning = false
      svg.style.cursor = 'grab'
      updateMiniMap()
    })

    // Zoom with Ctrl+Wheel
    svg.addEventListener('wheel', (e) => {
      if (!e.ctrlKey) return
      e.preventDefault()
      const rect = svg.getBoundingClientRect()
      const mouseX = e.clientX - rect.left
      const mouseY = e.clientY - rect.top
      
      // Convert mouse position to SVG coordinates
      const svgX = (mouseX / rect.width) * 1000
      const svgY = (mouseY / rect.height) * 1200
      
      const oldScale = scale
      const delta = e.deltaY > 0 ? 0.9 : 1.1
      scale = Math.min(maxScale, Math.max(minScale, scale * delta))
      
      // Adjust pan to zoom towards mouse position
      panX = panX - (svgX - panX / oldScale) * (scale - oldScale)
      panY = panY - (svgY - panY / oldScale) * (scale - oldScale)
      
      updateTransform()
    }, { passive: false })

    // Touch support
    // Touch support for panning and pinch-zoom
    let lastTouchDist = 0
    let lastTouchCenter = { x: 0, y: 0 }
    
    svg.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        isPanning = true
        startX = e.touches[0].clientX
        startY = e.touches[0].clientY
      } else if (e.touches.length === 2) {
        isPanning = false
        const t1 = e.touches[0], t2 = e.touches[1]
        lastTouchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY)
        lastTouchCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 }
      }
    }, { passive: true })

    document.addEventListener('touchmove', (e) => {
      if (e.touches.length === 1 && isPanning) {
        const dx = e.touches[0].clientX - startX
        const dy = e.touches[0].clientY - startY
        canvas.setAttribute('transform', `translate(${panX + dx},${panY + dy}) scale(${scale})`)
        updateMiniMap()
      } else if (e.touches.length === 2) {
        const t1 = e.touches[0], t2 = e.touches[1]
        const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY)
        const center = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 }
        
        // Pinch zoom
        if (lastTouchDist > 0) {
          const delta = dist / lastTouchDist
          const oldScale = scale
          scale = Math.min(maxScale, Math.max(minScale, scale * delta))
          
          // Pan while zooming
          const dx = center.x - lastTouchCenter.x
          const dy = center.y - lastTouchCenter.y
          panX += dx
          panY += dy
          
          updateTransform()
        }
        lastTouchDist = dist
        lastTouchCenter = center
      }
    }, { passive: true })

    document.addEventListener('touchend', (e) => {
      if (e.touches.length < 2) {
        lastTouchDist = 0
      }
      if (e.touches.length === 0 && isPanning) {
        // Finalize panning
        const matrix = canvas.getAttribute('transform') || 'translate(0,0) scale(1)'
        const m = matrix.match(/translate\(([-0-9.]+),([-0-9.]+)\)/)
        if (m) { panX = parseFloat(m[1]); panY = parseFloat(m[2]) }
        isPanning = false
      }
    })
  })
</script>
<style>
  /* Roadmap Container */
  .roadmap-container {
    position: relative;
  }

  .roadmap-controls {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    z-index: 10;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    align-items: flex-end;
  }

  .mini-map {
    width: 150px;
    height: 180px;
    background: hsl(var(--card));
    border: 1px solid hsl(var(--border));
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  }

  .mini-map-svg {
    width: 100%;
    height: 100%;
    background: hsl(var(--muted));
  }

  .mini-viewport {
    pointer-events: none;
  }

  .reset-btn {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.5rem 0.75rem;
    background: hsl(var(--primary));
    color: hsl(var(--primary-foreground));
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 500;
    transition: opacity 0.2s;
  }
  .reset-btn:hover { opacity: 0.85; }

  .zoom-info {
    background: hsl(var(--muted));
    color: hsl(var(--muted-foreground));
    padding: 0.3rem 0.6rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
    border: 1px solid hsl(var(--border));
  }

  .zoom-btns {
    display: flex;
    gap: 0.25rem;
  }
  .zoom-btn {
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: hsl(var(--card));
    border: 1px solid hsl(var(--border));
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    color: hsl(var(--foreground));
    transition: all 0.2s;
  }
  .zoom-btn:hover {
    background: hsl(var(--muted));
    border-color: hsl(var(--primary));
    color: hsl(var(--primary));
  }

  /* Roadmap Box */
  .roadmap-box {
    border-radius: 12px;
    background: linear-gradient(135deg, hsl(var(--muted)) 0%, hsl(var(--card)) 100%);
    border: 1px solid hsl(var(--border));
    overflow: hidden;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
  }

  .roadmap-svg {
    width: 100%;
    height: 600px;
    display: block;
    touch-action: none;
    user-select: none;
  }

  /* Edge Lines */
  .edge-line {
    stroke: hsl(var(--muted-foreground) / 0.4);
    stroke-width: 2.5;
    fill: none;
  }

  /* Node Boxes */
  .node-box rect {
    fill: hsl(var(--card));
    stroke: hsl(var(--primary));
    stroke-width: 2;
    transition: all 0.2s ease;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.15));
  }
  .node-box:hover rect {
    fill: hsl(var(--primary) / 0.15);
    stroke-width: 3;
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.25));
  }
  .node-box {
    cursor: pointer;
  }
  .node-box text {
    fill: hsl(var(--foreground));
    font-size: 14px;
    font-weight: 600;
    text-anchor: middle;
    dominant-baseline: middle;
    pointer-events: none;
  }

    /* Responsive */
    @media (max-width: 640px) {
      .roadmap-controls {
        top: 0.25rem;
        right: 0.25rem;
      }
      .mini-map {
        width: 100px;
        height: 120px;
      }
      .reset-btn span { display: none; }
      .reset-btn { padding: 0.5rem; }
    }
  </style>
