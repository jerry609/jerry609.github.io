---
title: '翻译：Anthropic——打造高效 Agent 的实践指南'
description: '翻译自 Anthropic 工程博客，系统总结了 Agent 的定义、常见架构模式、实用建议与最佳实践。'
publishDate: '2025-12-03'
tags: ['ai', 'agent', 'anthropic', '工程实践', '翻译']
---

> 原文：[Building effective agents](https://www.anthropic.com/engineering/building-effective-agents)
> 作者：Erik Schluntz, Barry Zhang
> 发布日期：2024年12月19日

在过去的一年里，我们与各行各业的数十个团队合作构建了大型语言模型（LLM）Agent。我们一致发现，最成功的实现并非使用复杂的框架或专门的库，而是采用了简单、可组合的模式。

在这篇文章中，我们将分享我们从客户合作及自身构建 Agent 过程中学到的经验，并为开发者提供构建高效 Agent 的实用建议。

## 什么是 Agent？

“Agent”有多种定义。一些客户将 Agent 定义为完全自主的系统，能够长时间独立运行，使用各种工具完成复杂任务。另一些客户则用这个词来描述遵循预定义工作流的更具指令性的实现。在 Anthropic，我们将所有这些变体归类为 **Agentic Systems（代理系统）**，但在架构上对 **Workflows（工作流）** 和 **Agents（代理）** 进行了重要区分：

*   **Workflows（工作流）** 是通过预定义代码路径编排 LLM 和工具的系统。
*   **Agents（代理）** 则是 LLM 动态指导其自身过程和工具使用，并保持对任务完成方式控制的系统。

下面，我们将详细探讨这两种类型的 Agentic Systems。在附录 1（“实践中的 Agent”）中，我们描述了客户发现使用此类系统特别有价值的两个领域。

## 什么时候（不）该用 Agent？

在构建 LLM 应用程序时，我们建议寻找最简单的解决方案，只有在需要时才增加复杂性。这可能意味着根本不需要构建 Agentic Systems。Agentic Systems 通常以延迟和成本为代价来换取更好的任务性能，你应该考虑这种权衡是否合理。

当需要更复杂的方案时，**Workflows** 为定义明确的任务提供了可预测性和一致性，而 **Agents** 则是需要大规模灵活性和模型驱动决策时的更好选择。然而，对于许多应用程序来说，通过检索和上下文示例优化单个 LLM 调用通常就足够了。

## 框架的选择与使用

有许多框架可以使 Agentic Systems 更容易实现，包括：

*   [Claude Agent SDK](https://platform.claude.com/docs/en/agent-sdk/overview)；
*   [Amazon Bedrock 的 AI Agent 框架](https://aws.amazon.com/bedrock/agents/)；
*   [Rivet](https://rivet.ironcladapp.com/)，一个拖放式 GUI LLM 工作流构建器；以及
*   [Vellum](https://www.vellum.ai/)，另一个用于构建和测试复杂工作流的 GUI 工具。

这些框架通过简化标准的低级任务（如调用 LLM、定义和解析工具以及链接调用），使入门变得容易。然而，它们通常会创建额外的抽象层，掩盖底层的提示和响应，使其更难调试。当一个更简单的设置就足够时，它们也可能诱使你增加复杂性。

我们建议开发者从直接使用 LLM API 开始：许多模式只需几行代码即可实现。如果你确实使用了框架，请确保你理解底层代码。对底层运作方式的错误假设是客户出错的常见原因。

请参阅我们的 [cookbook](https://github.com/anthropic-inc/anthropic-cookbook) 以获取一些示例实现。

## 构建模块，工作流和 Agent

在本节中，我们将探讨我们在生产环境中看到的 Agentic Systems 的常见模式。我们将从基础构建模块——增强型 LLM——开始，逐步增加复杂性，从简单的组合工作流到自主 Agent。

### 构建模块：增强型 LLM (The Augmented LLM)

Agentic Systems 的基本构建模块是增强了检索、工具和记忆等功能的 LLM。我们目前的模型可以主动使用这些能力——生成自己的搜索查询，选择合适的工具，并确定要保留哪些信息。

<img src="https://www.anthropic.com/_next/image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2Fd3083d3f40bb2b6f477901cc9a240738d3dd1371-2401x1000.png&w=3840&q=75" alt="增强型 LLM" style="display:block; margin:1.5rem auto; max-width:900px;" />

我们建议关注实现的两个关键方面：根据你的特定用例定制这些能力，并确保它们为你的 LLM 提供简单、文档齐全的接口。虽然实现这些增强功能的方法有很多，但一种方法是通过我们最近发布的 [Model Context Protocol (MCP)](https://www.anthropic.com/news/model-context-protocol)，它允许开发者通过简单的客户端实现与不断增长的第三方工具生态系统集成。

在本文的其余部分，我们将假设每个 LLM 调用都可以访问这些增强功能。

### Workflow: Prompt Chaining（链式提示）

链式提示将任务分解为一系列步骤，其中每个 LLM 调用都会处理上一个调用的输出。你可以在任何中间步骤添加程序化检查（见下图中的“Gate”），以确保流程仍在正轨上。

<img src="https://www.anthropic.com/_next/image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F7418719e3dab222dccb379b8879e1dc08ad34c78-2401x1000.png&w=3840&q=75" alt="链式提示工作流" style="display:block; margin:1.5rem auto; max-width:900px;" />

**何时使用此工作流：** 此工作流非常适合任务可以轻松且清晰地分解为固定子任务的情况。主要目标是通过让每个 LLM 调用处理更简单的任务，以延迟换取更高的准确性。

**链式提示有用的示例：**

*   生成营销文案，然后将其翻译成不同的语言。
*   编写文档大纲，检查大纲是否符合某些标准，然后根据大纲编写文档。

### Workflow: Routing（路由）

路由对输入进行分类，并将其定向到专门的后续任务。此工作流允许关注点分离，并构建更专业的提示。如果没有此工作流，针对一种输入进行优化可能会损害其他输入的性能。

<img src="https://www.anthropic.com/_next/image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F5c0c0e9fe4def0b584c04d37849941da55e5e71c-2401x1000.png&w=3840&q=75" alt="路由工作流" style="display:block; margin:1.5rem auto; max-width:900px;" />

**何时使用此工作流：** 路由适用于复杂任务，其中存在明显的类别，最好分别处理，并且分类可以由 LLM 或更传统的分类模型/算法准确处理。

**路由有用的示例：**

*   将不同类型的客户服务查询（一般问题、退款请求、技术支持）引导至不同的下游流程、提示和工具。
*   将简单/常见问题路由到像 Claude Haiku 这样更小、更具成本效益的模型，将困难/不寻常的问题路由到像 Claude Sonnet 这样能力更强的模型，以优化性能。

### Workflow: Parallelization（并行化）

LLM 有时可以同时处理一项任务，并以程序化方式聚合其输出。这种并行化工作流主要体现在两种变体中：

*   **Sectioning（分段）：** 将任务分解为并行运行的独立子任务。
*   **Voting（投票）：** 多次运行同一任务以获得多样化的输出。

<img src="https://www.anthropic.com/_next/image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F406bb032ca007fd1624f261af717d70e6ca86286-2401x1000.png&w=3840&q=75" alt="并行化工作流" style="display:block; margin:1.5rem auto; max-width:900px;" />

**何时使用此工作流：** 当分割的子任务可以并行化以提高速度，或者需要多个视角或尝试以获得更高置信度的结果时，并行化是有效的。对于具有多个考虑因素的复杂任务，当每个考虑因素由单独的 LLM 调用处理时，LLM 通常表现更好，从而可以专注于每个特定方面。

**并行化有用的示例：**

*   **Sectioning（分段）：**
    *   实施护栏，其中一个模型实例处理用户查询，而另一个模型实例筛选不当内容或请求。这通常比让同一个 LLM 调用同时处理护栏和核心响应效果更好。
    *   自动化评估 LLM 性能，其中每个 LLM 调用评估模型在给定提示下性能的不同方面。
*   **Voting（投票）：**
    *   审查代码中的漏洞，其中几个不同的提示会审查并在发现问题时标记代码。
    *   评估给定内容是否不当，通过多个提示评估不同方面或要求不同的投票阈值来平衡误报和漏报。

### Workflow: Orchestrator-Workers（编排器-工人）

在编排器-工人工作流中，中央 LLM 动态分解任务，将其分配给工人 LLM，并综合其结果。

<img src="https://www.anthropic.com/_next/image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F8985fc683fae4780fb34eab1365ab78c7e51bc8e-2401x1000.png&w=3840&q=75" alt="编排器-工人工作流" style="display:block; margin:1.5rem auto; max-width:900px;" />

**何时使用此工作流：** 此工作流非常适合无法预测所需子任务的复杂任务（例如，在编码中，需要更改的文件数量以及每个文件中更改的性质可能取决于任务）。虽然它在拓扑结构上相似，但与并行化的关键区别在于其灵活性——子任务不是预定义的，而是由编排器根据特定输入确定的。

**编排器-工人有用的示例：**

*   每次对多个文件进行复杂更改的编码产品。
*   涉及从多个来源收集和分析信息以获取可能相关信息的搜索任务。

### Workflow: Evaluator-Optimizer（评估器-优化器）

在评估器-优化器工作流中，一个 LLM 调用生成响应，而另一个 LLM 在循环中提供评估和反馈。

<img src="https://www.anthropic.com/_next/image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F14f51e6406ccb29e695da48b17017e899a6119c7-2401x1000.png&w=3840&q=75" alt="评估器-优化器工作流" style="display:block; margin:1.5rem auto; max-width:900px;" />

**何时使用此工作流：** 当我们有明确的评估标准，并且迭代改进能提供可衡量的价值时，此工作流特别有效。适合的两个标志是：第一，当人类表达反馈时，LLM 的响应可以得到明显的改善；第二，LLM 可以提供这样的反馈。这类似于人类作家在制作精美文档时可能经历的迭代写作过程。

**评估器-优化器有用的示例：**

*   文学翻译，翻译 LLM 最初可能无法捕捉到细微差别，但评估 LLM 可以提供有用的批评。
*   复杂的搜索任务，需要多轮搜索和分析来收集全面信息，评估器决定是否需要进一步搜索。

### Agents（自主 Agent）

随着 LLM 在关键能力（理解复杂输入、进行推理和规划、可靠地使用工具以及从错误中恢复）方面的成熟，Agent 正在生产环境中涌现。Agent 的工作始于人类用户的命令或互动讨论。一旦任务明确，Agent 就会独立规划和操作，可能会返回给人类以获取更多信息或判断。在执行过程中，Agent 必须在每一步从环境中获取“基本事实”（例如工具调用结果或代码执行）以评估其进度。然后，Agent 可以在检查点或遇到阻碍时暂停以获取人类反馈。任务通常在完成后终止，但也常见包括停止条件（例如最大迭代次数）以保持控制。

Agent 可以处理复杂的任务，但其实现通常很简单。它们通常只是在循环中使用基于环境反馈的工具的 LLM。因此，清晰、周到地设计工具集及其文档至关重要。我们在附录 2（“工具的提示工程”）中详细介绍了工具开发的最佳实践。

<img src="https://www.anthropic.com/_next/image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F58d9f10c985c4eb5d53798dea315f7bb5ab6249e-2401x1000.png&w=3840&q=75" alt="自主 Agent" style="display:block; margin:1.5rem auto; max-width:900px;" />

**何时使用 Agent：** Agent 可用于开放式问题，在这些问题中，很难或不可能预测所需的步骤数，并且无法硬编码固定路径。LLM 可能会运行很多轮，你必须对其决策能力有一定程度的信任。Agent 的自主性使其成为在受信任环境中扩展任务的理想选择。

Agent 的自主性质意味着更高的成本，以及错误复合的可能性。我们建议在沙盒环境中进行广泛的测试，并设置适当的护栏。

**Agent 有用的示例：**

以下示例来自我们自己的实现：

*   一个用于解决 SWE-bench 任务的编码 Agent，该任务涉及根据任务描述编辑许多文件；
*   我们的“计算机使用（computer use）”参考实现，其中 Claude 使用计算机来完成任务。

### 组合和定制这些模式

这些构建模块不是规定性的。它们是开发者可以塑造和组合以适应不同用例的常见模式。与任何 LLM 功能一样，成功的关键是衡量性能并迭代实现。重复一遍：你应该只在能明显改善结果时才考虑增加复杂性。

## 总结

在 LLM 领域的成功不在于构建最复杂的系统，而在于构建适合你需求的系统。从简单的提示开始，通过全面的评估对其进行优化，只有在简单的解决方案不足时才添加多步骤的 Agentic Systems。

在实现 Agent 时，我们尝试遵循三个核心原则：

1.  **保持 Agent 设计的简单性。**
2.  **通过显式展示 Agent 的规划步骤来优先考虑透明度。**
3.  **通过详尽的工具文档和测试，精心打造你的 Agent-计算机接口 (ACI)。**

框架可以帮助你快速入门，但不要犹豫减少抽象层，并在转向生产环境时使用基本组件进行构建。通过遵循这些原则，你可以创建不仅强大，而且可靠、可维护且受用户信任的 Agent。

## 致谢

本文由 Erik Schluntz 和 Barry Zhang 撰写。这项工作借鉴了我们在 Anthropic 构建 Agent 的经验以及我们客户分享的宝贵见解，对此我们深表感谢。

---

## 附录 1：实践中的 Agent

我们与客户的合作揭示了 AI Agent 的两个特别有前景的应用，证明了上述模式的实用价值。这两个应用都说明了 Agent 如何为需要对话和行动、有明确成功标准、启用反馈循环并整合有意义的人类监督的任务增加最大价值。

### A. 客户支持

客户支持将熟悉的聊天机器人界面与通过工具集成增强的功能相结合。这非常适合更开放式的 Agent，因为：

*   支持交互自然遵循对话流程，同时需要访问外部信息和操作；
*   可以集成工具来提取客户数据、订单历史记录和知识库文章；
*   诸如发放退款或更新工单之类的操作可以通过程序处理；以及
*   成功可以通过用户定义的解决方案清晰地衡量。

几家公司已经通过基于使用量的定价模型证明了这种方法的可行性，该模型仅对成功的解决方案收费，显示了对其 Agent 有效性的信心。

### B. 编码 Agent

软件开发领域显示出 LLM 功能的巨大潜力，能力从代码补全发展到自主解决问题。Agent 特别有效，因为：

*   代码解决方案可以通过自动化测试进行验证；
*   Agent 可以使用测试结果作为反馈来迭代解决方案；
*   问题空间定义明确且结构化；以及
*   输出质量可以客观衡量。

在我们自己的实现中，Agent 现在可以仅根据拉取请求描述解决 SWE-bench Verified 基准测试中的真实 GitHub 问题。然而，虽然自动化测试有助于验证功能，但人工审查对于确保解决方案符合更广泛的系统要求仍然至关重要。

<img src="https://www.anthropic.com/_next/image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F4b9a1f4eb63d5962a6e1746ac26bbc857cf3474f-2400x1666.png&w=3840&q=75" alt="代码 Agent 高层流程" style="display:block; margin:1.5rem auto; max-width:900px;" />

## 附录 2：工具的提示工程 (Prompt Engineering your Tools)

无论你构建哪种 Agentic System，工具都可能是你 Agent 的重要组成部分。工具使 Claude 能够通过在我们的 API 中指定其确切结构和定义来与外部服务和 API 进行交互。当 Claude 响应时，如果它计划调用工具，它将在 API 响应中包含一个工具使用块。工具定义和规范应得到与整体提示一样多的提示工程关注。在这个简短的附录中，我们将描述如何对你的工具进行提示工程。

通常有几种方法可以指定相同的操作。例如，你可以通过编写 diff 或重写整个文件来指定文件编辑。对于结构化输出，你可以返回 markdown 内的代码或 JSON 内的代码。在软件工程中，这些差异是表面的，可以无损地相互转换。然而，有些格式对 LLM 来说比其他格式难写得多。编写 diff 需要在编写新代码之前知道块头中有多少行发生了变化。编写 JSON 内的代码（与 markdown 相比）需要对换行符和引号进行额外的转义。

我们关于决定工具格式的建议如下：

*   **给模型足够的 Token 来“思考”，然后再让它把自己写进死胡同。**
*   **保持格式接近模型在互联网文本中自然看到的格式。**
*   **确保没有格式化的“开销”，例如必须准确计算数千行代码，或对其编写的任何代码进行字符串转义。**

一个经验法则是思考在人机交互 (HCI) 中投入了多少精力，并计划投入同样的精力来创建良好的 **Agent-计算机接口 (ACI)**。以下是关于如何做到这一点的一些想法：

*   **设身处地为模型着想。** 根据描述和参数，如何使用此工具是否显而易见，还是你需要仔细思考？如果是后者，那么对模型来说可能也是如此。一个好的工具定义通常包括示例用法、边缘情况、输入格式要求以及与其他工具的明确界限。
*   **你如何更改参数名称或描述以使事情更明显？** 把这想象成给团队中的初级开发人员写一个很棒的文档字符串（docstring）。当使用许多类似的工具时，这一点尤为重要。
*   **测试模型如何使用你的工具：** 在我们的 workbench 中运行许多示例输入，看看模型会犯什么错误，并进行迭代。
*   **对你的工具进行防错设计（Poka-yoke）。** 更改参数，使其更难犯错。

在为 SWE-bench 构建我们的 Agent 时，我们实际上在优化工具上花费的时间比在整体提示上花费的时间更多。例如，我们发现当 Agent 移出根目录后，模型会在使用相对文件路径的工具时犯错。为了解决这个问题，我们将工具更改为始终要求绝对文件路径——我们发现模型完美地使用了这种方法。
