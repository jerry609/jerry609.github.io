---
title: '系统设计的哲学'
description: '把系统当作一套“维持不变量的制度”，而不是一堆“实现功能的代码”'
publishDate: '2026-01-06'
tags: ['system-design', 'architecture', 'engineering']
---


---

## 哲学篇：以“不变量”对抗熵增

### 1. 先定义世界观：系统的意义是“维持不变量”

一个系统不是为了“实现功能”，而是为了**在变化、故障、需求冲突中维持少数关键不变量**。

*   你先说清楚：什么必须永远成立（安全边界、数据一致性底线、抽象边界、可用性承诺）。
*   其他东西都应该被允许变化、被试验、被替换、甚至被删掉。

> **K8s 的不变量**：声明式期望状态 + 单一事实来源（API/存储）+ 控制回路收敛。

### 2. 把“控制”与“执行”分离

**大脑只做决策，四肢只做动作。**

长期演进最怕“把环境差异写进核心”。所以你要把系统拆成：

*   **控制面（Control Plane）**：定义事实、做决策、协调、保证一致性与策略入口。
*   **数据/执行面（Data/Worker Plane）**：贴近环境完成动作，允许多实现并行。

> K8s 用 API/etcd/控制器/调度器当大脑，用 kubelet/runtime/CNI/CSI 当四肢。

### 3. 把系统做成“闭环”而不是“流程”

能演进的系统是**控制回路**：观察 → 比较 → 纠偏 → 再观察。

*   流程（Pipeline）擅长一次性完成；闭环擅长长期运行。
*   闭环天然容错、天然适配新增组件、天然支持渐进式迁移。

> 你设计的不是“做事”，而是“让现实持续逼近期望”。

### 4. 接口是宪法：内部可以重构，外部必须守约

长期演进的核心能力不是写新功能，而是**在不背叛用户的情况下改变内部**。

*   外部接口要版本化、可弃用但有规则、迁移有工具。
*   内部实现随便换，但必须在接口层面“看起来没变”。

> 稳定不是不变，而是“变化被约束在可承受的表面之下”。

### 5. 把变化安置在“插件边缘”，把稳定留在“内核中心”

你要主动设计一个“变化的容器”：

*   哪些东西变化快？（运行时、网络、存储、云厂商、策略）
*   就把它们做成可插拔的扩展点（接口/插件/外部控制器/Webhook）。
*   核心只保留少数通用抽象，不为每个特殊需求长出特例。

> 演进不是让核心长大，而是让生态在边缘繁荣。

### 6. 演进必须“可分段”：允许不一致，但要规定边界

真实世界里升级永远是渐进的、异构的、带偏斜的。所以你需要：

*   **版本偏斜策略**：谁可以比谁新/旧、允许差多少。
*   **Feature Gate / Capability Negotiation**：不同能力共存。
*   **分阶段迁移**：双写、读旧写新、灰度、回滚。

> 不能分段升级的系统，本质上是“只能重装”的系统。

### 7. 把治理当作架构的一部分

规模化演进不是技术问题，是**冲突管理问题**：

*   谁能改动“宪法”（接口、不变量）？
*   变更需要什么证据（KEP/RFC、测试、兼容性分析）？
*   谁对失败负责、怎么回滚、怎么弃用？

> 没有治理的架构，会被最短期的需求拉成泥球。

### 8. 可观测性是系统的“自我意识”

系统能否长期演进，取决于它能否在变化后回答：

*   “我现在是什么状态？”
*   “为什么变成这样？”
*   “影响多大？”
*   “如何回到期望？”

没有自我意识的系统，任何演进都是盲飞。

---

> **“设计口号”**
>
> **把系统当作一套“维持不变量的制度”，而不是一堆“实现功能的代码”。**
> 代码会被重写，制度（不变量、接口、闭环、扩展点、升级机制、治理）才决定它能活多久。

---

## 宪法篇：一页纸的架构评审清单

落地时，你可以直接用这三个问题拷问每次评审：
1.  **不变量是什么？**（哪些东西绝不能破）
2.  **变化放哪儿？**（哪些地方必须可插拔、可试验、可回滚）
3.  **怎么演进？**（版本/迁移/灰度/回滚/观测/治理是否闭环）

下面是一页版的 **“系统设计宪法”**：左边是评审 Checklist，右边是必须警惕的 Anti-Patterns。

### A. 宪法条款 Checklist（逐条勾选）

#### 1. 不变量优先
*   [ ] 写清楚 3–7 条系统不变量（安全边界 / 一致性底线 / 抽象边界 / 可用性承诺）。
*   [ ] 明确哪些是“可变的”，哪些是“不可变的”（并写出理由）。
*   [ ] 给不变量对应的“破坏后果”和“降级策略”。

#### 2. 单一事实来源
*   [ ] 系统有且只有一个权威状态来源（SoT），其他都是缓存或派生。
*   [ ] 状态读写路径清晰：谁能写？写什么？如何校验？如何审计？
*   [ ] 明确强一致与最终一致的边界（哪些必须强一致，哪些可以延迟收敛）。

#### 3. 控制与执行分离
*   [ ] 控制面只做决策/协调；执行面只做动作/反馈。
*   [ ] 执行面可以异构与替换（不同环境/供应商/实现并存）。
*   [ ] 控制面不依赖执行面的细节实现（只依赖契约/接口）。

#### 4. 闭环设计（Reconcile）
*   [ ] 每个关键能力都能描述成：观察 → 比较 → 纠偏 → 再观察。
*   [ ] “重试是安全的”（幂等/去重/重放可接受）。
*   [ ] 失败能收敛：有超时、退避、死信/隔离与人工介入路径。

#### 5. 接口即宪法（API/协议/Schema）
*   [ ] 外部接口版本化（versioning），并定义兼容与弃用政策。
*   [ ] Schema 可演进（可选字段、默认值、向前/向后兼容策略）。
*   [ ] 行为契约被测试锁定（golden tests / conformance tests）。

#### 6. 变化安置在“边缘扩展点”
*   [ ] 定义插件点/扩展点：策略、集成、运行时、存储/网络、调度等。
*   [ ] 扩展点有隔离与配额（不让插件把核心拖死）。
*   [ ] 可插拔不等于随意：扩展点也要版本化与契约。

#### 7. 演进机制可分段（升级/迁移/回滚）
*   [ ] 支持灰度：新旧组件/新旧能力可并存一段时间。
*   [ ] 数据/Schema 迁移有计划：双写/读旧写新/分阶段切换。
*   [ ] 有明确回滚策略（回滚会损失什么？如何补偿？）。

#### 8. 可观测性是第一等公民
*   [ ] 关键路径有指标、日志、追踪、事件（能定位“为什么坏了”）。
*   [ ] 有 SLO/报警策略（不是“有监控就行”）。
*   [ ] 变更可关联（版本/配置/特性开关）以便回归分析。

#### 9. 安全与多租户从一开始就成立
*   [ ] 认证/授权/审计/准入（或策略入口）有统一模型。
*   [ ] 默认最小权限；敏感操作可审计与可追责。
*   [ ] 租户隔离边界清晰（资源、网络、数据、控制面操作）。

#### 10. 治理与决策机制写进设计
*   [ ] 变更入口明确（RFC/KEP/设计评审标准）。
*   [ ] 所有权清晰（谁维护、谁值班、谁背锅）。
*   [ ] 兼容性与升级成本是评审硬门槛（不是“上线后再说”）。

### B. Anti-Patterns（出现任意一条就要拉警报）

*   **“泥球核心”**：需求都往核心塞，无扩展点，靠 if/else 区分环境。
*   **“双事实来源”**：多处状态各自为政，排障靠猜，最终靠重启。
*   **“流程式系统”**：一次性 pipeline，无幂等重试，故障放大小修补多。
*   **“没有版本的接口”**：随意改 API，无弃用期，系统被旧包袱锁死。
*   **“不可分段升级”**：必须全量同版本才能工作，规模越大越难演进。
*   **“扩展点无约束”**：插件阻塞关键路径，核心稳定性被外部实现绑架。
*   **“观测后补”**：先做功能再补监控，每次演进都是盲飞。
*   **“安全靠约定”**：默认管理员权限，无审计，规模化后必出事故。
*   **“治理缺失”**：无评审标准，决策债累积比技术债更致命。

---

## 落地篇：可执行的系统设计文档模版

这是一份可直接复制使用的系统设计文档骨架，每一节都对应上述“宪法条款”。

# 系统设计文档骨架（Template）

> **文档信息**
> * 标题：
> * 作者/Owner：
> * 评审人：
> * 状态：草案 / 评审中 / 已批准 / 已弃用
> * 目标发布日期：
> * 相关链接：PRD / RFC / 事故复盘 / 竞品分析

## 1. 摘要（1 页内）
*   **这是什么**：用一句话描述解决什么问题。
*   **为什么现在要做**：触发原因（增长、成本、稳定性、合规等）。
*   **核心结论**：选了什么方案？不做的代价？关键风险（Top 3）？

## 2. 背景与问题定义
*   **现状**：架构简述、痛点量化（延迟、QPS、故障率）。
*   **问题陈述**：明确范围（管哪里、不管哪里）、受影响对象。
*   **成功标准（SLO）**：可用性、延迟、成本等红线。

## 3. 不变量与原则（核心宪法）
在这写清楚 3–7 条系统不变量。对每条写清：**描述、为什么成立、破坏后果、降级策略**。
*   *示例：Invariant-1 单一事实来源……*

## 4. 需求与范围
*   **功能需求**：Must / Should / Could
*   **非功能需求**：可用性、扩展性、一致性（强/弱）、安全、成本。
*   **Out of Scope**：明确不做的事。

## 5. 关键场景与链路（真实链路）
*   **主要用户旅程**：Step 1 → Step 2... 每步的输入/输出/状态。
*   **失败与恢复链路**：超时、网络分区时，系统如何收敛/补偿。

## 6. 架构概览
*   **高层架构图**：控制面 vs 执行面。
*   **组件职责表**：职责、依赖、扩容方式、失败模式。
*   **数据流 vs 控制流**：哪些链路必须强一致。

## 7. 数据模型与一致性
*   **权威数据（SoT）**：存储在哪里、谁能写、如何审计。
*   **Schema/版本**：兼容策略、默认值。
*   **一致性模型**：并发冲突策略（锁/版本号/乐观并发）。
*   **迁移方案**：双写/回填顺序，回滚是否丢数据。

## 8. 接口与扩展点
*   **对外 API**：版本、限流、弃用策略。
*   **对内事件**：Topic、Schema、重放策略。
*   **扩展点**：插件位置、隔离机制（超时/配额）。

## 9. 演进与发布策略
*   **版本偏斜**：允许组件版本不一致的范围。
*   **灰度/Feature Gate**：开关控制、回滚触发条件。
*   **发布与回滚**：发布步骤、数据回滚补偿。

## 10. 可靠性工程（SRE）
*   **SLO**：错误预算、报警策略。
*   **容量与性能**：估算 QPS、依赖限流熔断。
*   **灾备**：RTO/RPO、备份演练。

## 11. 可观测性
*   **指标**：RED/USE 覆盖。
*   **日志**：结构化规范。
*   **追踪**：Trace 采样与关联。
*   **审计**：关键事件记录。

## 12. 安全与合规
*   认证授权、多租户隔离、数据合规。

## 13. 测试与验收
*   单元/集成/E2E、回归基线、上线准入条件。

## 14. 风险、权衡与备选
*   **风险清单**：概率、影响、缓解措施。
*   **备选方案**：为什么不选 A 或 B。
