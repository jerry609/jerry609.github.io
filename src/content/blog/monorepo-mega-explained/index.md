---
title: "Monorepo 详解：从理念到 Mega 实践"
description: "深入理解 Monorepo 的核心价值、技术挑战，以及为什么普通团队需要类似 Google Piper 的基础设施。介绍开源方案 Mega 如何填补这一空白。"
publishDate: "2025-12-09"
tags: ["Monorepo", "DevOps", "Git", "Mega", "Infrastructure"]
language: "zh-CN"
draft: false
---

## 一、什么是 Monorepo？

**Monorepo = Mono（单一）+ Repo（仓库）**

将组织内所有的代码放在同一个版本控制仓库中管理。

### Monorepo vs Polyrepo 对比

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  Polyrepo（传统多仓库模式）          Monorepo（单一仓库模式）                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐    ┌─────────────────────────────────┐│
│  │ repo-A  │ │ repo-B  │ │ repo-C  │    │          mega-repo              ││
│  │ 前端    │ │ 后端    │ │ 公共库  │    │  ┌───────────────────────────┐  ││
│  │ .git    │ │ .git    │ │ .git    │    │  │ frontend/                 │  ││
│  └─────────┘ └─────────┘ └─────────┘    │  │ backend/                  │  ││
│                                          │  │ libs/common/              │  ││
│  ┌─────────┐ ┌─────────┐ ┌─────────┐    │  │ services/auth/            │  ││
│  │ repo-D  │ │ repo-E  │ │ repo-F  │    │  │ services/payment/         │  ││
│  │ 认证    │ │ 支付    │ │ 工具库  │    │  │ tools/                    │  ││
│  │ .git    │ │ .git    │ │ .git    │    │  └───────────────────────────┘  ││
│  └─────────┘ └─────────┘ └─────────┘    │          .git (唯一)            ││
│                                          └─────────────────────────────────┘│
│  每个项目独立的 Git 仓库                 所有项目在同一个 Git 仓库            │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、Monorepo 要解决什么问题？

Polyrepo（多仓库）模式在实践中会遇到一系列痛点：

### 1. 依赖地狱 (Dependency Hell)

```
repo-A (前端)         repo-B (后端)         repo-C (公共库)
├── package.json      ├── go.mod            ├── common v1.0
│   common: "^1.0"    │   common v1.2       │
│                     │                     │
└── 使用 v1.0         └── 使用 v1.2         └── 最新是 v2.0

😱 问题: 每个仓库依赖不同版本，升级公共库要协调多个团队
        "先升级 C，再升级 B，最后升级 A" ← 顺序错了就炸
```

### 2. 跨仓库修改困难

**场景**：修改一个 API 接口，需要同时改前端和后端

**Polyrepo 流程**：
1. 在 repo-B 创建分支，修改后端 API
2. 提交 PR，等待 review，合并
3. 发布新版本 v1.2.3
4. 在 repo-A 创建分支，升级依赖到 v1.2.3
5. 修改前端代码适配新 API
6. 提交 PR，等待 review，合并
7. 部署...

> 😱 一个简单的改动需要跨 **2 个仓库、2 次 PR、2 次 review**

### 3. 代码复用困难

```
团队 A: "我写了一个很好用的日志库"
团队 B: "在哪？我怎么用？"
团队 A: "在 repo-X 里，你需要配置私有 npm registry..."
团队 B: "太麻烦了，我自己写一个吧"

结果: 组织内出现 N 个功能重复的日志库 😱
```

### 4. 工具链和标准不统一

| 仓库 | Lint | 格式化 | 测试框架 |
| :--- | :--- | :--- | :--- |
| repo-A | ESLint | Prettier | Jest |
| repo-B | TSLint | 无 | Mocha |
| repo-C | 无 | 无 | 无 |

每个仓库各自为政，代码质量参差不齐。

### 5. 原子提交不可能

**需求**："重命名 User 为 Account，涉及 10 个服务"

- **Polyrepo**：需要 10 个 PR，10 次 review，必须按顺序合并。中间状态系统不可用，出错回滚困难。
- **Monorepo**：1 个 PR，1 次 review，原子提交。要么全部生效，要么全部回滚 ✅

---

## 三、Monorepo 的优势

| 优势 | 说明 |
| :--- | :--- |
| **统一版本，无依赖地狱** | 所有代码在同一仓库，总是使用最新版本。修改公共库 → 自动影响所有使用者 → CI 立即告诉你哪里坏了 |
| **原子提交，跨项目修改简单** | 一个 commit 可以同时修改前端 + 后端 + 公共库。一个 PR，一次 review，一次部署 |
| **代码可见性，促进复用** | 所有代码在同一个地方，搜索即可发现。"有人写过这个功能吗？" → `grep` 一下就知道 |
| **统一工具链和标准** | 根目录统一配置 `eslint.config.js`, `tsconfig.json`, CI/CD。所有项目自动继承，保证一致性 |
| **简化团队协作** | 新人 onboarding：clone 一个仓库，所有代码都有了。跨团队协作：直接改代码，不需要等对方发版 |

---

## 四、为什么 Monorepo 需要"Google 级别的基础设施"？

这是关键问题。Monorepo 理念很美好，但实现起来有严重的技术挑战：

### 挑战 1：仓库体积爆炸 💥

| 公司 | 规模 |
| :--- | :--- |
| Google Piper | ~86 TB 代码，20 亿行，3500 万次提交 |
| Microsoft | ~300 GB (Windows 仓库) |

**传统 Git 的问题**：

```bash
$ git clone mega-repo
Cloning into 'mega-repo'...
Receiving objects: 100% (50000000/50000000), 50.00 GiB | 10.00 MiB/s
... 等待 1.5 小时 ...

$ git status
... 等待 30 秒 ...  (扫描数百万文件)

$ git log
... 等待 10 秒 ...  (遍历数千万提交)
```

> 😱 Git 在设计时没考虑这种规模，完全不可用

### 挑战 2：必须 clone 整个仓库

```
开发者: "我只想改 frontend/button.tsx，为什么要下载 50 GB？"

Git 的设计: 仓库是一个整体，要么全有，要么全无
           (sparse-checkout 只是不显示文件，数据还是要下载)
```

### 挑战 3：CI/CD 时间爆炸

**场景**：修改了 `libs/common/utils.ts`

```
天真的 CI: "common 改了，重新构建所有依赖它的 100 个项目"
           → 构建时间: 4 小时

需要: 智能的增量构建 + 依赖分析 + 分布式构建 + 远程缓存
```

### 挑战 4：权限控制

- **Git 权限**：仓库级别（要么能访问整个仓库，要么不能）
- **现实需求**：
  - 财务代码只有财务团队能看
  - 安全相关代码只有安全团队能改
  - 实习生不能碰生产配置

需要：**文件夹/文件级别的细粒度权限控制**

---

## 五、Google 的解决方案 vs 普通团队的困境

### Google 的解决方案

| 组件 | 功能 |
| :--- | :--- |
| **Piper** (版本控制) | 自研的集中式版本控制系统（不是 Git），服务端存储，客户端只下载需要的文件 |
| **CitC** (Clients in the Cloud) | 云端虚拟文件系统。开发者的 workspace 在云端，本地只是一个薄客户端。修改的文件按需同步，不需要 clone |
| **Blaze/Bazel** (构建系统) | 增量构建，只构建真正改变的部分。分布式构建，数千台机器并行。远程缓存，相同输入直接复用结果 |
| **Critique** (代码审查) | 支持超大规模的 code review 工具 |
| **基础设施** | 数万台服务器 |

### 普通团队的困境

> "我们想用 Monorepo，但是..."

- ❌ Git 在大仓库下太慢
- ❌ 没有云端 workspace，必须 clone 整个仓库
- ❌ GitHub/GitLab 不支持文件级权限
- ❌ 没有分布式构建集群
- ❌ 没有智能的增量 CI

**结果**：仓库一大就卡死，只能拆分成多个仓库 → 回到 Polyrepo 😢

---

## 六、Mega 如何填补这个空白

[Mega](https://github.com/web3infra-foundation/mega) 是一个开源项目，旨在为普通团队提供类似 Google Piper 的能力：

| 能力 | Google Piper | Mega |
| :--- | :--- | :--- |
| **版本控制** | Piper (自研) | Mega Server (Git 兼容)，服务端存储，支持标准 Git 协议 |
| **虚拟文件系统** | CitC (云端 workspace) | **Scorpio** (FUSE)，将 Monorepo 挂载为本地文件系统，按需加载，不需要 clone |
| **构建系统** | Blaze/Bazel | **Buck2 集成**，Meta 开源的构建系统，增量构建 + 远程缓存 |
| **权限控制** | 内部 ACL 系统 | **Saturn** (Cedar Policy)，基于 AWS Cedar 的策略引擎，文件/目录级别的细粒度权限 |
| **开源** | ❌ 不开源 | ✅ 完全开源 |
| **自托管** | ❌ 只能在 Google 内部 | ✅ 可以自己部署 |
| **Git 兼容** | ❌ 完全不同的协议 | ✅ 使用标准 Git 命令 |

---

## 七、总结

| 问题 | 答案 |
| :--- | :--- |
| **什么是 Monorepo?** | 将所有代码放在单一仓库中管理的实践 |
| **解决什么问题?** | 依赖管理混乱、跨项目修改困难、代码复用低、标准不统一 |
| **为什么需要特殊基础设施?** | Git 在设计时没考虑超大仓库：必须 clone 整个仓库（太大）、大仓库下所有操作都很慢、没有文件级权限控制、需要智能的增量构建系统 |
| **Mega 的价值?** | 开源的 Google Piper 替代品：Scorpio FUSE 按需加载、Git 兼容无学习成本、Cedar 细粒度权限、Buck2 高效构建、可自托管 |

> **一句话**：Mega 让没有 Google 级别资源的团队，也能享受 Monorepo 的好处。
