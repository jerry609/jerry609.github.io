---
publishDate: 2025-12-14
title: '学习'
tags: ['方法论']
---

## 01：先建"地图"，再补"点"

- 每学一个主题，先画 1 页结构图：**是什么 → 为什么 → 怎么做 → 何时用 → 常见坑**
- 任何零散知识点都必须"挂靠"到地图某一节点上（挂不上就说明没理解）

## 02：刷题/练习 = 产出模板，而不是堆数量

每做完一题，必须产出至少一项"可复用资产"：
- 算法：**题型识别条件 + 解题框架 + 复杂度 + 边界**
- 工程：**设计权衡 + 接口契约 + 失败模式 + 测试点**
- AI：**数据→模型→训练→评估→部署**的决策清单

题量只用来验证模板是否稳、是否能迁移。

## 03：记忆 = "能讲清 + 能手写复现"

你对一个概念的最低合格线：
1. 能用 3 句话解释给同学听
2. 能**不看资料**写出关键推导/伪代码/接口
3. 能给出一个反例或失败场景

需要硬记的（API/公式/术语）用"间隔回忆"，不反复阅读。

## 04：考试/面试 = 基础优先，技巧靠后

优先打穿三类基础：
- **定义与不变量**（为什么成立）
- **复杂度与资源**（时间/空间/IO/显存）
- **边界与异常**（空、极大、重复、溢出、并发、失败）

技巧只做两件事：提速、降错（不承担"从不会到会"的任务）。

## 05：用"错误分类"而不是"错题堆"

每个错误必须归因到一种可修复机制：
- 概念缺口 → 补地图节点
- 识别失败 → 补"题型判别条件"
- 推导/实现失误 → 补"步骤清单/单元测试"
- 边界漏掉 → 补"边界表"
- 工程假设错误 → 补"契约与约束"

然后只针对这一类做 2–5 个"定向练习"，直到同类错误消失。

## 06：算法学习的"三件套"

- **识别**：这题像哪类？判别条件是什么？
- **证明/不变量**：为什么正确？
- **实现与边界**：复杂度、初始化、溢出、重复元素

输出格式：`题型 → 关键条件 → 核心转移/贪心选择 → 复杂度 → 坑点`

## 07：软件工程的"四张清单"

每学一个工程主题，强制写：
1. **需求与约束**：吞吐/延迟/一致性/可用性/成本
2. **设计权衡**：你为何选 A 不选 B
3. **失败模式**：超时、重试风暴、雪崩、脏读、死锁…怎么兜底
4. **验证策略**：单测/集成/压测/可观测性指标与告警

工程的"会" = **在什么约束下做什么选择，出了事如何定位与止损**。

## 08：AI 学习的"端到端闭环"

- 数据：采集/清洗/泄漏检查/划分策略
- 模型：baseline → 提升点
- 训练：损失、优化、正则、超参、复现
- 评估：指标选择、误差分析、偏差/方差、鲁棒性
- 部署：延迟/吞吐、漂移监测、版本回滚

重点是"**诊断与迭代流程**"。

## 09：用"可交付物"驱动专注

每天学习必须产出一个可保存的成果（任选其一）：
- 1 页知识地图
- 1 个题型模板 + 3 个典型坑
- 1 份代码实现（含测试）
- 1 篇 300 字误差分析/设计权衡记录

**没有产出，就当那天没学。**

## 10：心流策略

- 一次只做一件事（只推导/只编码/只总结）
- 25–45 分钟一段，结束立刻写下"我刚刚真正学到的 1 条规律"
- 难度设置在"有点吃力但能做完"，心流才会出现
